#!/usr/bin/env bash

#########################################################################################################
#
#  Author:		Christian Zettel (ccztux)
#			2017-02-04
#			Copyright Â© 2017 Christian Zettel (cczux), all rights reserved
#			http://linuxinside.at
#			https://github.com/ccztux/glsysbackup
#
#  Last Modification:	Christian Zettel (ccztux)
#			2017-02-18
#
#  Description:		Generic Linux System Backup is an advanced backup tool written in bash.
#
#  Changelog:		1.0.1.a Initial revision
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#########################################################################################################


trap 'sigHandler SIGTERM' SIGTERM
trap 'sigHandler SIGINT' SIGINT
trap 'sigHandler SIGHUP' SIGHUP
trap 'sigHandler SIGABRT' SIGABRT
trap 'sigHandler SIGQUIT' SIGQUIT
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR
trap 'sigHandler EXIT' EXIT


#-----------------------
# Script info variables:
#-----------------------

script_name="${0##*/}"
script_version="1.0.0.a"
script_author="ccztux"
script_last_modification_date="2017-02-18"
script_license="GNU GPLv3"
script_description="${script_name} (Generic Linux System Backup) is an advanced backup tool written in bash."
script_argc="$#"
script_pid="$$"
script_exit_code="255"
script_lock_file="/var/lock/${script_name}"
script_hostname="${HOSTNAME%%.*}"
script_major_bashversion="${BASH_VERSINFO[0]}"
script_common_required_binaries=("rm" "mv")



#-------------------------
# Configuration variables:
#-------------------------

root_privileges_required="1"

backup_destination_path="/var/backups/"
backup_filename="${script_name}.${script_hostname}.tar.gz"
backup_full_path="${backup_destination_path}${backup_filename}"
items_to_backup="/home/ /root/ /var/lib/mpd/ /usr/local/bin/ /boot/config.txt"
items_to_exclude=("/root/old" "/tmp/var")

backup_rotating_required="1"
backup_rotating_files_to_keep="5"

installed_packages_required="1"
installed_packages_filename="/root/installed_packages_filename.txt"

backup_encryption_required="1"
backup_encryption_password="test1234"
backup_encryption_filename="${backup_full_path//tar.gz/aes.tar.gz}"

log_to_syslog="1"
log_to_file="0"
log_file="/var/log/${script_name}.log"
log_to_stdout="1"



#-----------
# Functions:
#-----------

usage()
{
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
echo "Usage: ${script_name} OPTIONS

Author:                 ${script_author}
Last modification:      ${script_last_modification_date}
Version:                ${script_version}
License:                ${script_license}

Description:            ${script_description}

OPTIONS:
   -h        Shows this help.
   -o	     Override lock in case ${script_name} was terminated abnormally.
   -v        Shows script version."
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
}

printScriptInfos()
{
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
echo "Author:                 ${script_author}
Last modification:      ${script_last_modification_date}
Version:                ${script_version}
License:                ${script_license}

Description:            $script_description"
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
}

checkRootPrivileges()
{
	logHandler "Check if root priviliges are required..."
	if [ "$root_privileges_required" == "1" ] ;then
		logHandler "Root privileges are required, checking privileges..."
		if [ "$UID" != "0" ] ;then
			logHandler "You must run this script as root, terminating..."
			script_exit_code="10"
			exit
		fi
	else
		logHandler "Root privileges are not required..."
	fi
}

getUser()
{
	local script_exec_user=
	local rc=
	logHandler "Get user which starts the script..."
	checkBin "whoami"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Required binary: 'whoami' found."
	else
		logHandler "Required binary: 'whoami' not found, exiting..."
		script_exit_code="127"
		exit
	fi
	if [ ! -z "$SUDO_USER" ] ;then
		script_exec_user="$SUDO_USER"
	else
		script_exec_user="$(${whoami_bin})"
	fi
	logHandler "${script_name} was started by: '${script_exec_user}'."
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=("$1")
	logHandler "Check if common required binaries: '${required_binaries[*]// /, }' exists..."
	for bin in ${required_binaries[*]}
	   do
		checkBin "$bin"
		rc="$?"
		if [ "$rc" == "0" ] ;then
			logHandler "Required binary: '${bin}' found."
		else
			logHandler "Required binary: '${bin}' not found, exiting..."
			script_exit_code="127"
			exit
		fi
	   done
}

checkBashVersion()
{
	logHandler "Checking bash version..."
	if [ -z "$script_major_bashversion" ] ;then
		logHandler "Could not determine bash version, exiting..."
		script_exit_code="40"
		exit
	else
		case "$script_major_bashversion" in
					3)
						logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
						;;
					4)
						logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
						;;
					*)
						logHandler "Bash version: '${script_major_bashversion}' doesnt meet requirements, terminating..."
						script_exit_code="41"
						exit
						;;
		esac
	fi
}

checkAlreadyRunningInstance()
{
	local rc=
	logHandler "Check if another instance of: '${script_name}' is already running..."
	checkBin "pgrep"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Required binary: 'pgrep' found."
	else
		logHandler "Required binary: 'pgrep' not found, exiting..."
		script_exit_code="127"
		exit
	fi
	local running_script_pids="$(${pgrep_bin} "$script_name")"
	running_script_pids="${running_script_pids//${script_pid}/}"
	running_script_pids="${running_script_pids//$'\n'/, }"
	checkLock
	rc="$?"
	if ([ "$rc" != "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "$rc" == "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		if [ "$override_lock" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-o'."
			another_instance_is_running="1"
			script_exit_code="51"
			exit
		fi
	elif ([ "$rc" == "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="52"
		exit
	elif ([ "$rc" != "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="53"
		exit
	fi
}

checkLock()
{
	local rc=
	logHandler "Check if lock file: '${script_lock_file}' exists."
	checkLocalFileExists "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Lock file: '${script_lock_file}' exist."
		return 0
	else
		logHandler "Lock file: '${script_lock_file}' doesnt exist."
		return 1
	fi
}

setLock()
{
	local rc=
	logHandler "Setting lock..."
	echo "$script_pid" > "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful."
		script_exit_code="60"
		exit
	fi
}

removeLock()
{
	local rc=
	logHandler "Removing lock..."
	${rm_bin} "$script_lock_file" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="70"
		exit
	fi
}

overrideLock()
{
	logHandler "Override lock, because you want it..."
	removeLock
	setLock
}

checkLocalFileExists()
{
	local file="$1"
	if [ -f "$file" ] ;then
		if [ -s "$file" ] ;then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

checkLocalDirectoryExists()
{
	local directory="$1"
	if [ -d "$directory" ] ;then
		return 0
	else
		return 1
	fi
}

checkBin()
{
	local binary="$1"
	local _bin=
	local rc=
	_bin="$(which "${binary}" 2>&1)"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		export ${binary}_bin="$_bin"
		return 0
	else
		return 1
	fi
}

checkTrailingSlash()
{
	local path="$1"
	if [[ "$path" =~ ^(.*)\/$ ]] ;then
		removeLastChar "$path"
	else
		echo "$path"
	fi
}

removeLastChar()
{
	local string="$1"
	echo "${string:0:$((${#string} - 1))}"
}

getSysPackageManager()
{
	local supported_syspackage_managers=("rpm" "dpkg")
	local available_syspackage_managers=()
	local rc=
	logHandler "Check if installed packages are required..."
	if [ "$installed_packages_required" == "1" ] ;then
		logHandler "Installed packages are required..."
		logHandler "Getting system package manager..."
		for syspackman in ${supported_syspackage_managers[*]}
		   do
			checkBin "$syspackman"
			rc="$?"
			if [ "$rc" == "0" ] ;then
				available_syspackage_managers+=("$syspackman")
			fi
		   done
		if [ "${#available_syspackage_managers[*]}" -gt "1" ] ;then
			logHandler "More than one supported syspackage managers found: '${available_syspackage_managers[*]}', dont know what to do..."
			script_exit_code="80"
			exit
		else
			logHandler "Supported system package manager we found is: '${available_syspackage_managers[*]}'."
			createInstalledPackagesFile
		fi
	else
		logHandler "Installed packages are not required."
	fi
}

createInstalledPackagesFile()
{
	local rc=
	logHandler "Creating installed packages file: '${installed_packages_filename}'..."
	case "${available_syspackage_managers}" in
						rpm)
							${rpm_bin} -qa > "${installed_packages_filename}"
							;;
						dpkg)
							${dpkg_bin} --get-selections > "${installed_packages_filename}"
							;;
						*)
							logHandler "Ooop! Someting went terribly wrong in function: '${FUNCNAME}', exiting..."
							script_exit_code="90"
							exit
							;;
	esac
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Creating installed packages file was successful."
	else
		logHandler "Creating installed packages file was not successful."
		script_exit_code="100"
		exit
	fi
}

buildExcludeOpts()
{
	logHandler "Check if we need to build excluding options..."
	if [ ! -z "${items_to_exclude[*]}" ] ;then
		logHandler "Building of excluding options are required..."
		exclude_string=()
		for item in ${items_to_exclude[*]}
		   do
			exclude_string+=("--exclude='$(checkTrailingSlash "${item}")'")
		   done
		logHandler "We build the following excluding options: '${exclude_string[*]}'."
	else
		logHandler "We dont have to build excluding options..."
	fi
}

rotateHandler()
{
	logHandler "Check if backup rotating is required..."
	if [ "$backup_rotating_required" == "1" ] ;then
		logHandler "Backup rotating is required..."
		local rc=
		logHandler "Rotating backup files..."
		if [ "$backup_encryption_required" == "1" ] ;then
			file="$backup_encryption_filename"
		else
			file="$backup_full_path"
		fi
		backup_rotating_files_to_keep=$((backup_rotating_files_to_keep - 1))
		while [ "$backup_rotating_files_to_keep" -gt "0" ]
		   do
			local file_helper=$((backup_rotating_files_to_keep - 1))
			if [ "$backup_rotating_files_to_keep" != "1" ] ;then
				checkLocalFileExists "${file}.${file_helper}"
				rc="$?"
				if [ "$rc" == "0" ] ;then
					${mv_bin} "${file}.${file_helper}" "${file}.${backup_rotating_files_to_keep}" 2>&1 | logHandler
					rc="${PIPESTATUS[0]}"
					if [ "$rc" == "0" ] ;then
						logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${backup_rotating_files_to_keep}' was successful."
					else
						logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${backup_rotating_files_to_keep}' was not successful."
					fi
				fi
			else
				checkLocalFileExists "${file}"
				rc="$?"
				if [ "$rc" == "0" ] ;then
					${mv_bin} "${file}" "${file}.${backup_rotating_files_to_keep}" 2>&1 | logHandler
					rc="${PIPESTATUS[0]}"
					if [ "$rc" == "0" ] ;then
						logHandler "Rotating file: '${file}' ==> '${file}.${backup_rotating_files_to_keep}' was successful."
					else
						logHandler "Rotating file: '${file}' ==> '${file}.${backup_rotating_files_to_keep}' was not successful."
					fi
				fi
			fi
			backup_rotating_files_to_keep=$((backup_rotating_files_to_keep - 1))
		   done
	else
		logHandler "Backup rotating is not required..."
	fi
}

logHandler()
{
	local log_message="${1//\`/}"
	local log_timestamp=
	local stdin_data_available=
	local rc=
	if [ -z "$log_message" ] ;then
		if [ -t "0" ] ;then
			stdin_data_available="0"
		else
			stdin_data_available="1"
		fi
		if [ "$stdin_data_available" == "1" ] ;then
			logHandlerStdinHelper
		fi
	else
		if [ "$log_to_syslog" == "1" ];then
			if [ -z "$logger_bin" ] ;then
				checkBin "logger"
				rc="$?"
				if [ "$rc" != "0" ] ;then
					echo "Required binary: 'logger' not found, exiting..."
					script_exit_code="127"
					exit
				fi
			fi
			${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
		fi
		if [ "$log_to_file" == "1" ];then
			if [ -z "$date_bin" ] ;then
				checkBin "date"
				rc="$?"
				if [ "$rc" != "0" ] ;then
					echo "Required binary: 'date' not found, exiting..."
					script_exit_code="127"
					exit
				fi
			fi
			log_timestamp="$(${date_bin} '+%Y-%m-%d %H:%M:%S')"
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}" >> "${log_file}"
		fi
		if [ "$log_to_stdout" == "1" ] ;then
			if [ -z "$log_timestamp" ] ;then
				if [ -z "$date_bin" ] ;then
					checkBin "date"
					rc="$?"
					if [ "$rc" != "0" ] ;then
						echo "Required binary: 'date' not found, exiting..."
						script_exit_code="127"
						exit
					fi
				fi
				log_timestamp="$(${date_bin} '+%Y-%m-%d %H:%M:%S')"
			fi
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}"
		fi
	fi
}

logHandlerStdinHelper()
{
	while read -r stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

sigHandler()
{
	local signal="$1"
	local bash_lineno="$2"
	local bash_command="$3"
	local rc=
	case "$signal" in
		SIGTERM)
			logHandler "Caught ${signal}, preparing for exiting script..."
			script_exit_code="143"
			exit
			;;
		SIGINT)
			logHandler "Caught ${signal}, preparing for exiting script..."
			script_exit_code="130"
			exit
			;;
		SIGHUP)
			logHandler "Caught ${signal}, preparing for exiting script..."
			script_exit_code="129"
			exit
			;;
		SIGABRT)
			logHandler "Caught ${signal}, preparing for exiting script..."
			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			logHandler "Caught ${signal}, preparing for exiting script..."
			script_exit_code="129"
			exit
			;;
		ERR)
			logHandler "Caught ${signal}, at line number: '${bash_lineno}', command: '${bash_command}'. Preparing for exiting script..."
			script_exit_code="1"
			exit
			;;
		EXIT)
			logHandler "Caught ${signal}, preparing for exiting..."
			if [ "$another_instance_is_running" != "1" ] ;then
				checkLock
				rc="$?"
				if [ "$rc" == "0" ] ;then
					removeLock
				fi
			fi
			logHandler "Script was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."
			exit $script_exit_code
			;;
		*)
			logHandler "Signal: '${signal}' received in function: '${FUNCNAME}' but dont know what to do..."
			return 1
			;;
	esac
}

makeBackup()
{
	local rc=
	checkBin "tar"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Required binary: 'tar' found."
	else
		logHandler "Required binary: 'tar' not found, exiting..."
		script_exit_code="127"
		exit
	fi
	local backup_cmd="${tar_bin} -cvzf ${backup_full_path} ${items_to_backup}"
	logHandler "Starting backup job..."
	checkLocalDirectoryExists "$backup_destination_path"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup directory: '${backup_destination_path}' exists."
	else
		logHandler "Backup directory: '${backup_destination_path}' doesnt exist."
	fi
	eval "${backup_cmd} ${exclude_string[*]} 2>&1" | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup job was successful."
		if [ "$backup_encryption_required" == "1" ] ;then
			encryptBackup
		else
			logHandler "We did a great job, initiating termination..."
			script_exit_code="131"
			exit
		fi
	else
		logHandler "Backup job was not successful."
		script_exit_code="132"
		exit
	fi
}

encryptBackup()
{
	local rc=
	logHandler "Encrypting backup file: '${backup_full_path}'..."
	checkBin "openssl"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Required binary: 'openssl' found."
	else
		logHandler "Required binary: 'openssl' not found, exiting..."
		script_exit_code="127"
		delUnencryptedBackupFile
	fi
	${openssl_bin} aes-256-cbc -salt -in "${backup_full_path}" -out "${backup_encryption_filename}" -k "${backup_encryption_password}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Encrypting job was successful."
		logHandler "HINT: You can use the following command, to decrypt your backup: '${openssl_bin} aes-256-cbc -d -salt -in ${backup_encryption_filename} -out ${backup_full_path}'."
		delUnencryptedBackupFile
	else
		logHandler "Encrypting job was not successful."
		script_exit_code="140"
		exit
	fi
}

delUnencryptedBackupFile()
{
	local rc=
	logHandler "Deleting unencrypted backup file: '${backup_full_path}'..."
	${rm_bin} "${backup_full_path}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Deleting of unencrypted backup file: '${backup_full_path}' was successful."
		logHandler "We did a great job, initiating termination..."
		if [ "$script_exit_code" != "127" ] ;then
			script_exit_code="0"
		fi
		exit
	else
		logHandler "Deleting of unencrypted backup file: '${backup_full_path}' was not successful."
		script_exit_code="150"
		exit
	fi
}



#-------------
# Get options:
#-------------

while getopts "h.o:v." OPTION
   do
	case "$OPTION" in
			h)
				usage
				script_exit_code="160"
				exit
				;;
			o)
				override_lock="1"
				;;
			v)
				printScriptInfos
				script_exit_code="161"
				exit
				;;
			?)
				usage
				script_exit_code="162"
				exit
				;;
	esac
   done



#------
# Main:
#------

logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
checkRootPrivileges
getUser
checkRequiredBinaries "${script_common_required_binaries[*]}"
checkAlreadyRunningInstance
checkBashVersion
rotateHandler
getSysPackageManager
buildExcludeOpts
makeBackup

logHandler "Ooops! Something went terribly wrong... Exiting..."
exit
