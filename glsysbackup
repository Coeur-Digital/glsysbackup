#!/usr/bin/env bash

#========================================================================================================
#
#  Author:		Christian Zettel (ccztux)
#			2017-02-04
#			Copyright Â© 2017 Christian Zettel (ccztux), all rights reserved
#			http://linuxinside.at
#			https://github.com/ccztux/glsysbackup
#
#  Last Modification:	Christian Zettel (ccztux)
#			2017-03-17
#
#  Description:		Generic Linux System Backup is an advanced backup tool written in bash.
#
#  Changelog:		1.0.0		Initial revision
#			1.0.1.a		First alpha version
#			1.0.1-alpha2	Second alpha version
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#========================================================================================================

# shellcheck disable=SC2154
# shellcheck disable=SC1001

#--------------
# Bash options:
#--------------

set -o pipefail



#-------
# Traps:
#-------

trap 'sigHandler SIGTERM' SIGTERM
trap 'sigHandler SIGINT' SIGINT
trap 'sigHandler SIGHUP' SIGHUP
trap 'sigHandler SIGABRT' SIGABRT
trap 'sigHandler SIGQUIT' SIGQUIT
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR
trap 'sigHandler EXIT' EXIT



#-----------------------
# Script info variables:
#-----------------------

script_name="${0##*/}"
script_version="1.0.0-alpha2"
script_author="ccztux"
script_last_modification_date="2017-03-17"
script_license="GNU GPLv3"
script_description="${script_name} (Generic Linux System Backup) is an advanced backup tool written in bash."
script_pid="$$"
script_exit_code="255"
script_lock_file="/var/lock/${script_name}"
script_hostname="${HOSTNAME%%.*}"
script_major_bashversion="${BASH_VERSINFO[0]}"



#-------------------------
# Configuration variables:
#-------------------------

log_to_syslog="1"
log_to_file="0"
log_file="/var/log/${script_name}.log"
log_to_stdout="1"

root_privileges_required="1"

backup_destination_path="/var/backups/"
backup_filename="${script_name}.${script_hostname}.tar.gz"
backup_full_path="${backup_destination_path}${backup_filename}"
items_to_backup="/home/ /root/ /var/lib/mpd/ /usr/local/bin/ /boot/config.txt"
items_to_exclude=("/root/old" "/tmp/var/")

backup_rotating_required="1"
backup_rotating_files_to_keep="5"

installed_packages_required="1"
installed_packages_filename="/root/installed_packages_filename.txt"

backup_encryption_required="1"
backup_encryption_password="test1234"
backup_encryption_filename="${backup_full_path//tar.gz/aes.tar.gz}"

pre_backup_script="/home/pi/pre.sh"
post_backup_script="/home/pi/post.sh"



#-----------
# Functions:
#-----------

printUsage()
{
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi

	echo "Usage: ${script_name} OPTIONS"
	echo 
	echo "Author:                 ${script_author}"
	echo "Last modification:      ${script_last_modification_date}"
	echo "Version:                ${script_version}"
	echo "License:                ${script_license}"
	echo
	echo "Description:            ${script_description}"
	echo
	echo "OPTIONS:"
	echo "   -h        Shows this help."
	echo "   -o        Override lock in case ${script_name} was terminated abnormally."
	echo "   -v        Shows script version."

	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
}

printScriptInfos()
{
	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi

	echo "Author:                 ${script_author}"
	echo "Last modification:      ${script_last_modification_date}"
	echo "Version:                ${script_version}"
	echo "License:                ${script_license}"
	echo
	echo "Description:            $script_description"

	if [ "$log_to_stdout" == "1" ] ;then
		echo
	fi
}

setDefaultValues()
{
	# already not in use
	return
}

checkRootPrivileges()
{
	logHandler "Check if root priviliges are required..."

	if [ "$root_privileges_required" == "1" ] ;then
		logHandler "Root privileges are required, checking privileges..."
		if [ "$UID" == "0" ] ;then
			logHandler "HOORAY, we have root privileges... :)"
		else
			logHandler "You must run this script as root, terminating..."
			script_exit_code="10"
			exit
		fi
	else
		logHandler "Root privileges are not required..."
	fi
}

getUser()
{
	local script_exec_user=
	local rc=

	logHandler "Get user which starts the script..."

	if [ ! -z "$SUDO_USER" ] ;then
		script_exec_user="$SUDO_USER"
	else
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started by: '${script_exec_user}'."
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=()

	if [ "$log_to_syslog" == "1" ] ;then
		required_binaries+=("logger")
	fi

	if ([ "$log_to_file" == "1" ] || [ "$log_to_stdout" == "1" ]) ;then
		required_binaries+=("datee")
	fi

	if [ "$backup_rotating_required" == "1" ] ;then
		required_binaries+=("mv")
	fi

	if [ "$backup_encryption_required" == "1" ] ;then
		required_binaries+=("openssl")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "tar" "mkdir")

	for bin in ${required_binaries[*]}
	   do
		checkBin "$bin"
		rc="$?"
		if [ "$bin" == "logger" ] ;then
			logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
		fi
		if [ "$rc" != "0" ] ;then
			logHandler "Required binary: '${bin}' not found, exiting..."
			script_exit_code="127"
			exit
		fi
	   done
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "$script_major_bashversion" ] ;then
		logHandler "Could not determine bash version, exiting..."
		script_exit_code="40"
		exit
	else
		case "$script_major_bashversion" in
					3)
						logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
						;;
					4)
						logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
						;;
					*)
						logHandler "Bash version: '${script_major_bashversion}' doesnt meet requirements, terminating..."
						script_exit_code="41"
						exit
						;;
		esac
	fi
}

checkAlreadyRunningInstance()
{
	local rc=
	local running_script_pids=
	running_script_pids="$(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_name}(.*)$")"
	running_script_pids="${running_script_pids//${script_pid}/}"
	running_script_pids="${running_script_pids//$(${pgrep_bin} -d " " -P "${script_pid}")/}"
	running_script_pids="${running_script_pids//\ /, }"
	
	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="$?"
	if ([ "$rc" != "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "$rc" == "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		if [ "$override_lock" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-o'."
			another_instance_is_running="1"
			script_exit_code="51"
			exit
		fi
	elif ([ "$rc" == "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="52"
		exit
	elif ([ "$rc" != "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="53"
		exit
	fi
}

checkLock()
{
	local rc=

	logHandler "Check if lock file: '${script_lock_file}' exists."

	checkRegularFileExists "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Lock file: '${script_lock_file}' exist."
		return 0
	else
		logHandler "Lock file: '${script_lock_file}' doesnt exist."
		return 1
	fi
}

setLock()
{
	local rc=

	logHandler "Setting lock..."

	set -o noclobber
	echo "$script_pid" > "$script_lock_file"
	rc="$?"
	set +o noclobber

	if [ "$rc" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="60"
		exit
	fi
}

removeLock()
{
	local rc=

	logHandler "Removing lock..."

	${rm_bin} "$script_lock_file" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="70"
		exit
	fi
}

overrideLock()
{
	logHandler "Overriding lock, because you want it..."
	removeLock
	setLock
}

checkRegularFileExists()
{
	local file="$1"
	if [ -f "$file" ] ;then
		return 0
	else
		return 1
	fi
}

checkLocalDirectoryExists()
{
	local directory="$1"
	if [ -d "$directory" ] ;then
		return 0
	else
		return 1
	fi
}

checkBin()
{
	local binary="$1"
	local _bin=
	local rc=

	_bin="$(which "${binary}" 2>&1)"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		export ${binary}_bin="$_bin"
		return 0
	else
		return 1
	fi
}

checkTrailingSlash()
{
	local path="$1"
	if [[ "$path" =~ ^(.*)\/$ ]] ;then
		return 1
	else
		return 0
	fi
}

removeLastChar()
{
	local string="$1"
	echo "${string:0:$((${#string} - 1))}"
}

getSysPackageManager()
{
	local supported_syspackage_managers=("rpm" "dpkg")
	local available_syspackage_managers=()
	local rc=

	logHandler "Check if installed packages are required..."

	if [ "$installed_packages_required" == "1" ] ;then
		logHandler "Installed packages are required..."
		logHandler "Getting system package manager..."
		for syspackman in ${supported_syspackage_managers[*]}
		   do
			checkBin "$syspackman"
			rc="$?"
			if [ "$rc" == "0" ] ;then
				available_syspackage_managers+=("$syspackman")
			fi
		   done
		if [ "${#available_syspackage_managers[*]}" -gt "1" ] ;then
			logHandler "More than one supported syspackage managers found: '${available_syspackage_managers[*]}', dont know what to do..."
			script_exit_code="80"
			exit
		else
			syspackage_manager="${available_syspackage_managers[*]}"
			logHandler "Supported system package manager we found is: '${available_syspackage_managers[*]}'."
			createInstalledPackagesFile
		fi
	else
		logHandler "Installed packages are not required."
	fi
}

createInstalledPackagesFile()
{
	local rc=
	logHandler "Creating installed packages file: '${installed_packages_filename}'..."
	case "${syspackage_manager}" in
						rpm)
							${syspackage_manager} -qa > "${installed_packages_filename}"
							;;
						dpkg)
							${syspackage_manager} --get-selections > "${installed_packages_filename}"
							;;
						*)
							logHandler "Ooop! Someting went terribly wrong in function: '${FUNCNAME[0]}', exiting..."
							script_exit_code="90"
							exit
							;;
	esac
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Creating installed packages file was successful."
	else
		logHandler "Creating installed packages file was not successful."
		script_exit_code="100"
		exit
	fi
}

buildExcludeOpts()
{
	local rc=
	logHandler "Check if we need to build excluding options..."
	if [ ! -z "${items_to_exclude[*]}" ] ;then
		logHandler "Building of excluding options are required..."
		exclude_string=()
		for item in ${items_to_exclude[*]}
		   do
			checkTrailingSlash "${item}"
			rc="$?"
			if [ "$rc" == "0" ] ;then	
				exclude_string+=("--exclude='${item}'")
			else
				exclude_string+=("--exclude='$(removeLastChar "${item}")'")
			fi
		   done
		logHandler "We build the following excluding options: '${exclude_string[*]}'."
	else
		logHandler "We dont have to build excluding options..."
	fi
}

rotateHandler()
{
	logHandler "Check if backup rotating is required..."

	if [ "$backup_rotating_required" == "1" ] ;then
		logHandler "Backup rotating is required..."
		local rc=
		logHandler "Rotating backup files..."
		if [ "$backup_encryption_required" == "1" ] ;then
			file="$backup_encryption_filename"
		else
			file="$backup_full_path"
		fi
		backup_rotating_files_to_keep=$((backup_rotating_files_to_keep - 1))
		while [ "$backup_rotating_files_to_keep" -gt "0" ]
		   do
			local file_helper=$((backup_rotating_files_to_keep - 1))
			if [ "$backup_rotating_files_to_keep" != "1" ] ;then
				checkRegularFileExists "${file}.${file_helper}"
				rc="$?"
				if [ "$rc" == "0" ] ;then
					${mv_bin} "${file}.${file_helper}" "${file}.${backup_rotating_files_to_keep}" 2>&1 | logHandler
					rc="${PIPESTATUS[0]}"
					if [ "$rc" == "0" ] ;then
						logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${backup_rotating_files_to_keep}' was successful."
					else
						logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${backup_rotating_files_to_keep}' was not successful."
					fi
				fi
			else
				checkRegularFileExists "${file}"
				rc="$?"
				if [ "$rc" == "0" ] ;then
					${mv_bin} "${file}" "${file}.${backup_rotating_files_to_keep}" 2>&1 | logHandler
					rc="${PIPESTATUS[0]}"
					if [ "$rc" == "0" ] ;then
						logHandler "Rotating file: '${file}' ==> '${file}.${backup_rotating_files_to_keep}' was successful."
					else
						logHandler "Rotating file: '${file}' ==> '${file}.${backup_rotating_files_to_keep}' was not successful."
					fi
				fi
			fi
			backup_rotating_files_to_keep=$((backup_rotating_files_to_keep - 1))
		   done
	else
		logHandler "Backup rotating is not required..."
	fi
}

logHandler()
{
	local log_message="${1//\`/}"
	local log_timestamp=
	local log_helper_missing_binary="0"
	local stdin_data_available=
	local rc=

	if [ -z "$log_message" ] ;then
		if [ -t "0" ] ;then
			stdin_data_available="0"
		else
			stdin_data_available="1"
		fi

		if [ "$stdin_data_available" == "1" ] ;then
			logHandlerStdinHelper
		fi
	else
		if ([ "$log_to_file" == "1" ] || [ "$log_to_stdout" == "1" ] || [ -z "$logger_bin" ] && [ ! -z "$date_bin" ]) ;then
			log_timestamp="$(${date_bin} '+%Y-%m-%d %H:%M:%S')"
		fi

		if ([ "$log_to_syslog" == "1" ] && [ ! -z "$logger_bin" ]) ;then
			${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
		elif ([ "$log_to_syslog" == "1" ] && [ -z "$logger_bin" ] && [ ! -z "$date_bin" ]) ;then
			log_helper_missing_binary="1"
			echo "[${log_timestamp}] ${script_name}: [${script_pid}] [Binary: 'logger' not found] ${log_message}"
		elif ([ "$log_to_syslog" == "1" ] && [ -z "$logger_bin" ] && [ -z "$date_bin" ]) ;then
			log_helper_missing_binary="1"
			echo "[Binary: 'date' not found] ${script_name}: [${script_pid}] [Binary: 'logger' not found] ${log_message}"
		fi

		if ([ "$log_to_file" == "1" ] && [ ! -z "$date_bin" ]) ;then
			echo "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}" >> "${log_file}"
		elif ([ "$log_to_file" == "1" ] && [ -z "$date_bin" ]) ;then
			echo "[Binary: 'date' not found] ${script_name}: [${script_pid}] ${log_message}" >> "${log_file}"
		fi

		if ([ "$log_to_stdout" == "1" ] && [ ! -z "$date_bin" ] && [ "$log_helper_missing_binary" != "1" ]) ;then
			echo "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}"
		elif ([ "$log_to_stdout" == "1" ] && [ -z "$date_bin" ] && [ "$log_helper_missing_binary" != "1" ]) ;then
			echo "[Binary: 'date' not found] ${script_name}: [${script_pid}] ${log_message}"
		fi
	fi
}

logHandlerStdinHelper()
{
	while read -r stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

sigHandler()
{
	local signal="$1"
	local bash_lineno="$2"
	local bash_command="$3"
	local rc=

	case "$signal" in
		SIGTERM)
			script_exit_code="143"
			exit
			;;
		SIGINT)
			script_exit_code="130"
			exit
			;;
		SIGHUP)
			script_exit_code="129"
			exit
			;;
		SIGABRT)
			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			script_exit_code="129"
			exit
			;;
		ERR)
			logHandler "Caught ${signal}, at line number: '${bash_lineno}', command: '${bash_command}'." 
			script_exit_code="1"
			exit
			;;
		EXIT)
			logHandler "Caught ${signal}, preparing for exiting script..."
			if [ "$backup_encryption_required" == "1" ] ;then
				delUnencryptedBackupFile
			fi
			if [ "$script_exit_code" != "127" ] ;then
				logHandler "We did a great job, initiating termination..."
				script_exit_code="0"
			fi
			if [ "$another_instance_is_running" != "1" ] ;then
				checkLock
				rc="$?"
				if [ "$rc" == "0" ] ;then
					removeLock
				fi
			fi
			logHandler "Script was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."
			exit $script_exit_code
			;;
		*)
			logHandler "Signal: '${signal}' received in function: '${FUNCNAME[0]}' but dont know what to do..."
			return 1
			;;
	esac
}

makeBackup()
{
	local rc=
	local backup_cmd="${tar_bin} -cvzf ${backup_full_path} ${items_to_backup}"

	logHandler "Starting backup job..."

	checkLocalDirectoryExists "$backup_destination_path"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup directory: '${backup_destination_path}' exists."
	else
		logHandler "Backup directory: '${backup_destination_path}' doesnt exist."
		${mkdir_bin} "${backup_destination_path}" 2>&1 | logHandler
		rc="${PIPESTATUS[0]}"
		if [ "$rc" == "0" ] ;then
			logHandler "Creating backup directory: '${backup_destination_path}' was successful."
		else
			logHandler "Creating backup directory: '${backup_destination_path}' was not successful."
			script_exit_code="131"
			exit
		fi
	fi
	eval "${backup_cmd} ${exclude_string[*]} 2>&1" | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup job was successful."
		script_exit_code="0"
	else
		logHandler "Backup job was not successful."
		script_exit_code="132"
		exit
	fi
}

encryptBackup()
{
	local rc=

	if [ "$backup_encryption_required" == "1" ] ;then
		logHandler "Encrypting backup file: '${backup_full_path}'..."
		${openssl_bin} aes-256-cbc -salt -in "${backup_full_path}" -out "${backup_encryption_filename}" -k "${backup_encryption_password}" 2>&1 | logHandler
		rc="${PIPESTATUS[0]}"
		if [ "$rc" == "0" ] ;then
			logHandler "Encrypting job was successful."
			logHandler "HINT: For decrypting use this command: '${openssl_bin} aes-256-cbc -d -salt -in ${backup_encryption_filename} -out ${backup_full_path}'."
			script_exit_code="0"
		else
			logHandler "Encrypting job was not successful."
			script_exit_code="140"
			exit
		fi
	fi
}

delUnencryptedBackupFile()
{
	local rc=

	logHandler "Check if unencrypted backup file: '${backup_full_path}' exists..."

	checkRegularFileExists "${backup_full_path}"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Unencrypted backup file: '${backup_full_path}' exists..."
		logHandler "Deleting unencrypted backup file: '${backup_full_path}'..."
		${rm_bin} "${backup_full_path}" 2>&1 | logHandler
		rc="${PIPESTATUS[0]}"
		if [ "$rc" == "0" ] ;then
			logHandler "Deleting of unencrypted backup file: '${backup_full_path}' was successful."
		else
			logHandler "Deleting of unencrypted backup file: '${backup_full_path}' was not successful."
			script_exit_code="150"
		fi
	else
		logHandler "Unencrypted backup file: '${backup_full_path}' doenst exist..."
	fi
}

executePreBackupScript()
{
	local rc=

	if [ ! -z "$pre_backup_script" ] ;then
		logHandler "Pre backup script: '${pre_backup_script}' is defined..."
		checkRegularFileExists "$pre_backup_script"
		rc="$?"
		if [ "$rc" == "0" ] ;then
			logHandler "Pre backup script: '${pre_backup_script}' exists, so we will execute it..."
			eval "${pre_backup_script} 2>&1" | logHandler
			rc="${PIPESTATUS[0]}"
			if [ "$rc" == "0" ] ;then
				logHandler "Execution of pre backup script seems to be successful. rc: '${rc}'."
			else
				logHandler "Execution of pre backup script seems to be unssuccessful. rc: '${rc}'."
			fi
		else
			logHandler "Pre backup script: '${pre_backup_script}' doesnt exist, could not execute it..."
		fi
	else
		logHandler "Pre backup script: '${pre_backup_script}' is not defined..."
	fi
}

executePostBackupScript()
{
	local rc=

	if [ ! -z "$post_backup_script" ] ;then
		logHandler "Post backup script: '${post_backup_script}' is defined..."
		checkRegularFileExists "$post_backup_script"
		rc="$?"
		if [ "$rc" == "0" ] ;then
			logHandler "Post backup script: '${post_backup_script}' exists, so we will execute it..."
			eval "${post_backup_script} 2>&1" | logHandler
			rc="${PIPESTATUS[0]}"
			if [ "$rc" == "0" ] ;then
				logHandler "Execution of post backup script seems to be successful. rc: '${rc}'."
			else
				logHandler "Execution of post backup script seems to be unssuccessful. rc: '${rc}'."
			fi
		else
			logHandler "Post backup script: '${post_backup_script}' doesnt exist, could not execute it..."
		fi
	else
		logHandler "Post backup script: '${post_backup_script}' is not defined..."
	fi
}



#-------
# Start:
#-------

checkRequiredBinaries



#-------------
# Get options:
#-------------

OPTERR="0"
while getopts ":hov" OPTION
   do
	logHandler "Getting options from cli..."
	case "$OPTION" in
			h)
				printUsage
				script_exit_code="160"
				exit
				;;
			o)
				override_lock="1"
				;;
			v)
				printScriptInfos
				script_exit_code="161"
				exit
				;;
			\?)
				logHandler "Invalid option: -${OPTARG}"
				printUsage
				script_exit_code="162"
				exit
				;;
			:)
				logHandler "Option: -${OPTARG} requires an argument."
				printUsage
				script_exit_code="163"
				exit
				;;
	esac
   done



#------
# Main:
#------

setDefaultValues
checkRootPrivileges
getUser
checkAlreadyRunningInstance
checkBashVersion
rotateHandler
getSysPackageManager
buildExcludeOpts
executePreBackupScript
makeBackup
encryptBackup
executePostBackupScript



#----------------------
# Should never reached:
#----------------------

logHandler "Ooops! Something went terribly wrong... Exiting..."
exit
