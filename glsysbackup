#!/usr/bin/env bash

#========================================================================================================
#
#  Author:		Christian Zettel (ccztux)
#			2017-02-04
#			http://linuxinside.at
#
#  Copyright:		Copyright © 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:	https://github.com/ccztux/glsysbackup
#
#  Last Modification:	Christian Zettel (ccztux)
#			2017-04-23
#
#  Description:		Generic Linux System Backup is an advanced backup tool written in bash.
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#========================================================================================================


#--------------
# Bash options:
#--------------

set -o noclobber || { printf "Setting essential bash option: 'noclobber' was not successful, terminating...\n" ; exit 245 ; }
set -o nounset || { printf "Setting essential bash option: 'nounset' was not successful, terminating...\n" ; exit 246 ; }
set -o pipefail || { printf "Setting essential bash option: 'pipefail' was not successful, terminating...\n" ; exit 247 ; }



#-------
# Traps:
#-------

trap 'siggHandler SIGTERM' SIGTERM || { printf "Setting essential trap for signal: 'SIGTERM' was not successful, terminating...\n" ; exit 248 ; }
trap 'sigHandler SIGINT' SIGINT || { printf "Setting essential trap for signal: 'SIGINT' was not successful, terminating...\n" ; exit 249 ; }
trap 'sigHandler SIGHUP' SIGHUP || { printf "Setting essential trap for signal: 'SIGHUP' was not successful, terminating...\n" ; exit 250 ; }
trap 'sigHandler SIGABRT' SIGABRT || { printf "Setting essential trap for signal: 'SIGABRT' was not successful, terminating...\n" ; exit 251 ; }
trap 'sigHandler SIGQUIT' SIGQUIT || { printf "Setting essential trap for signal: 'SIGQUIT' was not successful, terminating...\n" ; exit 252 ; }
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR || { printf "Setting essential trap for signal: 'ERR' was not successful, terminating...\n" ; exit 253 ; }
trap 'sigHandler EXIT' EXIT || { printf "Setting essential trap for signal: 'EXIT' was not successful, terminating...\n" ; exit 254 ; }



#-----------------------
# Script info variables:
#-----------------------

script_pid="${BASHPID}"
script_name="${0##*/}"
script_hostname="${HOSTNAME%%.*}"
script_version="1.0.1"
script_author="Christian Zettel (ccztux)"
script_copyright="Copyright © 2017 ${script_author}, all rights reserved"
script_project_website="https://github.com/ccztux/glsysbackup"
script_last_modification_date="2017-04-23"
script_license="GNU GPLv3"
script_description="${script_name} (Generic Linux System Backup) is an advanced backup tool written in bash."
script_exit_code="255"
script_another_instance_is_running="0"
script_bypass_exit_routines="0"
script_override_lock="0"
script_lock_directory="/var/lock/"
script_lock_file="${script_lock_directory}${script_name}"



#-------------------------
# Configuration variables:
#-------------------------

#---------
# Logging:
#---------

# enable log to file. (possible values: 1|0)
log_to_file="0"

# log directory
log_directory="/var/log/"

# filename of logfile
log_filename="${script_name}.log"

# enable log to stdout (possible values: 1|0)
log_to_stdout="1"

# enable log to system logfile (possible values: 1|0)
log_to_syslog="1"

# timestamp format for log messages.
log_timestamp_format="%Y-%m-%d %H:%M:%S"



#------------
# Privileges:
#------------

# enable this to ensure glsysbackup is running with root privileges (possible values: 1|0)
root_privileges_required="1"



#--------
# Renice:
#--------

# enable reniceing of glsysbackup and child procs (possible values: 1|0)
re_nice_enabled="0"

# set renice priority (HINT: have a look at: 'man renice')
re_nice_priority="19"



#-----------
# Re-ionice:
#-----------

# enable re-ioniceing of glsysbackup and child procs (possible values: 1|0)
re_ionice_enabled="0"

# set re-ionice scheduling class (HINT: have a look at: 'man ionice')
re_ionice_scheduling_class="2"

# set re-ionice priority (HINT: have a look at: 'man ionice')
re_ionice_priority="7"



#----------
# Rotation:
#----------

# enable backup rotation (possible values: 1|0)
backup_rotation_enabled="1"

# number of backup files to keep
backup_rotation_files_to_keep="5"



#--------------------
# Installed packages:
#--------------------

# enable the creation of installed packages file (possible values: 1|0)
installed_packages_enabled="1"

# force this package manager to create installed packages file, if you have more than one package manager installed (possible values: rpm|dpkg|pacman|equery|pkgutil)
installed_packages_forced_manager=""

# file name of installed packages
installed_packages_filename="/root/installed_syspackages.txt"



#--------
# Backup:
#--------

# enable backup compression (possible values: 1|0)
backup_compression_enabled="1"

# backup compression type (possible values: gzip|bzip2|xz|lzip|lzma|lzop)
backup_compression_type="gzip"

# enable backup verbose mode
backup_verbose_mode_enabled="1"

# set backup destination path
backup_destination_path="/var/backups/"

# set backup filename
backup_filename="${script_name}.${script_hostname}.tar.gz"

# files and folders you want to backup
backup_items=(
"/etc/"
"/home/"
"/root/"
"/var/lib/mpd/"
"/usr/local/bin/"
"/boot/config.txt"
)

# exclude this items from backup (HINT: have a look at: 'man tar')
backup_exlude_items=(
"/old.backups"
"/old.mysqldumps/"
)



#------------
# Encryption:
#------------

# enable backup encryption with openssl (possible values: 1|0)
backup_encryption_enabled="1"

# set password for encryption
backup_encryption_password="test1234"




#-------------------
# Pre backup script:
#-------------------

# enable pre backup script functionality (possible values: 1|0)
pre_backup_script_enabled="1"

# path to pre backup script 
pre_backup_script="/home/pi/pre.sh"

# exit glsysbackup in case execution of pre backup script was not successful
pre_backup_exit_when_unsuccessful="1"



#--------------------
# Post backup script:
#--------------------

# enable post backup script functionality (possible values: 1|0)
post_backup_script_enabled="1"

# path to post backup script 
post_backup_script="/home/pi/post.sh"

# exit glsysbackup in case execution of post backup script was not successful
post_backup_exit_when_unsuccessful="1"



#-----------
# Functions:
#-----------

printUsage()
{
	if [ "${log_to_stdout}" == "1" ] ;then
		printf "\n"
	fi

	printf "Usage: %s OPTIONS\n\n" "${script_name}"
	printf "Author:\t\t\t%s\n" "${script_author}"
	printf "Last modification:\t%s\n" "${script_last_modification_date}"
	printf "Version:\t\t%s\n\n" "${script_version}"
	printf "Description:\t\t%s\n\n" "${script_description}"
	printf "OPTIONS:\n"
	printf "   -h\t\tShows this help.\n"
	printf "   -o\t\tOverride lock in case %s was terminated abnormally.\n" "${script_name}"
	printf "   -v\t\tShows detailed version information.\n"

	if [ "${log_to_stdout}" == "1" ] ;then
		printf "\n"
	fi
}

printScriptInfos()
{
	if [ "${log_to_stdout}" == "1" ] ;then
		printf "\n"
	fi

	printf "Author:\t\t\t%s\n" "${script_author}"
	printf "Project website:\t%s\n" "${script_project_website}"
	printf "License:\t\t%s\n\n" "${script_license}"
	printf "Last modification:\t%s\n" "${script_last_modification_date}"
	printf "Version:\t\t%s\n\n" "${script_version}"
	printf "Description:\t\t%s\n\n" "${script_description}"
	printf "Copyright:\t\t%s\n" "${script_copyright}"

	if [ "${log_to_stdout}" == "1" ] ;then
		printf "\n"
	fi
}

checkBin()
{
	local binary="${1:-}"
	local _bin=
	local rc=

	_bin="$(which "${binary}" 2>&1)"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		export "${binary}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=
	local supported_syspackage_managers=("rpm" "dpkg" "pacman" "equery" "pkgutil")

	if [ "${log_to_syslog}" == "1" ] ;then
		required_binaries+=("logger")
	fi

	if ([ "${log_to_file}" == "1" ] || [ "${log_to_stdout}" == "1" ]) ;then
		if ([ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]) ;then
			date_bin_printf="1"
			date_bin="printf"
		else
			required_binaries+=("date")
		fi
	fi

	if [ "${backup_rotation_enabled}" == "1" ] ;then
		required_binaries+=("mv")
	fi

	if [ "${backup_encryption_enabled}" == "1" ] ;then
		required_binaries+=("openssl")
	fi

	if [ "${re_nice_enabled}" == "1" ] ;then
		required_binaries+=("renice")
	fi

	if [ "${re_ionice_enabled}" == "1" ] ;then
		required_binaries+=("ionice")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "tar" "mkdir" "kill")

	for bin in "${required_binaries[@]}"
	   do
		checkBin "${bin}"
		rc="$?"

		if [ "${rc}" != "0" ] ;then
			binaries_not_found+=("${bin}")
		fi
	   done

	logHandlerSetConfig
	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"

	if [ "${#binaries_not_found[*]}" -gt "1" ] ;then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[*]}" -eq "1" ] ;then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi

	if [ "${installed_packages_enabled}" == "1" ] ;then
		available_syspackage_managers=()

		if [ -z "${installed_packages_forced_manager}" ] ;then
			for syspackman in "${supported_syspackage_managers[@]}"
			   do
				checkBin "${syspackman}"
				rc="$?"

				if [ "${rc}" == "0" ] ;then
					available_syspackage_managers+=("${syspackman}")
				fi
			   done
		else
			checkBin "${installed_packages_forced_manager}"
			rc="$?"

			if [ "${rc}" == "0" ] ;then
				available_syspackage_managers+=("${installed_packages_forced_manager}")
			fi
		fi

	fi
}

logHandlerSetConfig()
{
	log_conf="$((2#0000000))"

	if [ "${date_bin_printf:-}" == "1" ] ;then
		date_cmd="${date_bin:-} '%(${log_timestamp_format})T\n'"
	else
		date_cmd="${date_bin:-} '+${log_timestamp_format}'"
	fi

	if ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "0" ]) ;then
		return ${log_conf}
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000001))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000010))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000011))"
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000100))"
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000101))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000110))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000111))"
	fi

	if ([ -z "${date_bin:-}" ] && [ -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0001000))"
	elif ([ ! -z "${date_bin:-}" ] && [ -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0010000))"
	elif ([ -z "${date_bin:-}" ] && [ ! -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0100000))"
	elif ([ ! -z "${date_bin:-}" ] && [ ! -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#1000000))"
	fi

	return ${log_conf}
}

logHandlerStdinHelper()
{
	while read -r stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=

	if [ -z "${log_message:-}" ] ;then
		if [ ! -t "0" ] ;then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"

		case "${log_conf:-}" in
					8|16|32|64) # log nothing
						return
						;;
					9) # log to file, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					10) # log to stdout, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					11) # log to syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					12) # log to file and stdout, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					13) # log to file and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					14) # log to stdout and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					15) # log to file, stdout and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					17) # log to file, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					18) # log to stdout, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					19) # log to syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					20) # log to file and stdout, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					21) # log to file and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					22) # log to stdout and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					23) # log to file, stdout and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] [Logger bin not found] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					33) # log to file, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					34) # log to stdout, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					35) # log to syslog, zero date, nonzero logger
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					36) # log to file and stdout, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					37) # log to file and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					38) # log to stdout and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					39) # log to file, stdout and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] %s\n" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					65) # log to file, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					66) # log to stdout, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					67) # log to syslog, nonzero date, nonzero logger
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					68) # log to file and stdout, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					69) # log to file and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					70) # log to stdout and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					71) # log to file, stdout and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] %s\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
		esac
	fi
}

sigHandler()
{
	local signal="${1:-}"
	local bash_lineno="${2:-}"
	local bash_command="${3:-}"
	local rc=

	case "${signal}" in
		SIGTERM)
			logHandler "Caught: '${signal}', preparing for exiting..."
			script_exit_code="143"
			exit
			;;
		SIGINT)
			logHandler "Caught: '${signal}', preparing for exiting..."
			script_exit_code="130"
			exit
			;;
		SIGHUP)
			logHandler "Caught: '${signal}', preparing for exiting..."
			script_exit_code="129"
			exit
			;;
		SIGABRT)
			logHandler "Caught: '${signal}', preparing for exiting..."
			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			logHandler "Caught: '${signal}', preparing for exiting..."
			script_exit_code="129"
			exit
			;;
		ERR)
			logHandler "Caught: '${signal}', at line number: '${bash_lineno}', command: '${bash_command}'." 
			script_exit_code="1"
			exit
			;;
		EXIT)
			logHandler "Caught: '${signal}', exiting script..."

			if [ "${script_bypass_exit_routines}" != "1" ] ;then
				cleanUp

				if [ "${script_exit_code}" == "0" ] ;then
					logHandler "We did a great job. :)"
				else
					logHandler "Ooops!!! Something went wrong. :("
					logHandler "Read the log or output to determine what exactly went wrong."
				fi

				if [ "${script_another_instance_is_running}" != "1" ] ;then
					checkLock
					rc="$?"

					if [ "${rc}" == "0" ] ;then
						removeLock
					fi
				fi
			else
				logHandler "We hope you are informed better now. :P This was a lazy job. :)"
			fi

			logHandler "Script was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."

			if [ ! -z "${kill_bin:-}" ] ;then
				${kill_bin} -s "${signal}" "${script_pid}"
			fi

			exit ${script_exit_code}
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}' but dont know what to do with it..."
			return 1
			;;
	esac
}

checkLock()
{
	local rc=

	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read and writeable..."

	checkFilePermissions "${script_lock_file}"
	rc="$?"

	case "${rc}" in
		6|7)
			logHandler "Lock file exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Lock file doesnt exist."
			return 1
			;;
		*)
			logHandler "Lock file exists, but it is not read/writeable."
			return 2
			;;
	esac
}

setLock()
{
	local rc=

	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkDirectoryPermissions "${script_lock_directory}"
	rc="$?"

	case "${rc}" in
		3|7)
			logHandler "Script lock directory exists and permissions are ok."
			;;
		10)
			logHandler "Script lock directory doesnt exist."
			logHandler "Creating script lock directory..."

			# shellcheck disable=SC2154
			${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Creating script lock directory was successful."
			else
				logHandler "Creating script lock directory was not successful."
				script_exit_code="10"
				exit
			fi
			;;
		*)
			logHandler "Script lock directory exists but permissions are not ok, exiting."
			script_exit_code="11"
			exit
			;;
	esac

	logHandler "Setting lock..."

	printf "%s\n" "${script_pid}" > "${script_lock_file}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="12"
		exit
	fi
}

removeLock()
{
	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	${rm_bin} "${script_lock_file}" 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="20"
		exit
	fi
}

overrideLock()
{
	logHandler "Overriding lock, because you want it..."

	removeLock
	setLock
}

cleanUp()
{
	logHandler "Now we are doing some cleanup jobs..."

	delUnencryptedBackupFile
	delInstalledPackagesFile
}

delUnencryptedBackupFile()
{
	local rc=

	if [ "${backup_encryption_enabled}" == "1" ] ;then
		logHandler "Backup encryption is enabled, now we check if unencrypted backup file exists, if it is writeable and delete it..."
		logHandler "Check if unencrypted backup file: '${backup_full_path}' exists and if it is writeable..."

		checkFilePermissions "${backup_full_path}"
		rc="$?"

		case "${rc}" in
			2|3|6|7)
				logHandler "Unencrypted backup file  exists and it is writeable."
				logHandler "Deleting unencrypted backup file..."

				# shellcheck disable=SC2154
				${rm_bin} "${backup_full_path}" 2>&1 | logHandler

				if [ "${PIPESTATUS[0]}" == "0" ] ;then
					logHandler "Deleting unencrypted backup file was successful."
				else
					logHandler "Deleting unencrypted backup file was not successful."
					script_exit_code="30"
				fi
				;;
			10)
				logHandler "Unencrypted backup file doesnt exist, nothing to do."
				;;
			*)
				logHandler "Unencrypted backup file is not writeable, we can not delete it."
				script_exit_code="311"
				;;
		esac
	fi
}

delInstalledPackagesFile()
{
	local rc=

	if [ "${installed_packages_enabled}" == "1" ] ;then
		logHandler "Installed packages functionality is enabled, now we check if the file exists, if it is writeable and delete it..."
		logHandler "Check if installed packages file: '${installed_packages_filename}' exists and if it is writeable..."

		checkFilePermissions "${installed_packages_filename}"
		rc="$?"

		case "${rc}" in
			2|3|6|7)
				logHandler "Installed packages file exists and is writeable."
				logHandler "Deleting installed packages file..."

				# shellcheck disable=SC2154
				${rm_bin} "${installed_packages_filename}" 2>&1 | logHandler

				if [ "${PIPESTATUS[0]}" == "0" ] ;then
					logHandler "Deleting installed packages file was successful."
				else
					logHandler "Deleting installed packages file was not successful."
					script_exit_code="40"
				fi
				;;
			10)
				logHandler "Installed packages file doesnt exist, nothing to do."
				;;
			*)
				logHandler "Installed packages file exists, but it is not writeable, we can not delete it."
				script_exit_code="41"
				;;
		esac
	fi
}

checkRegularFileExists()
{
	local file="${1:-}"

	if [ -f "${file}" ] ;then
		return 0
	else
		return 1
	fi
}

checkFilePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkRegularFileExists "${file}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		if [ -x "${file}" ] ;then
			file_permission="$((file_permission + 2#0001))"
		fi

		if [ -w "${file}" ] ;then
			file_permission="$((file_permission + 2#0010))"
		fi

		if [ -r "${file}" ] ;then
			file_permission="$((file_permission + 2#0100))"
		fi
	else
		file_permission="$((2#1010))"
	fi

	return "${file_permission}"
}

checkDirectoryExists()
{
	local directory="${1:-}"

	if [ -d "${directory}" ] ;then
		return 0
	else
		return 1
	fi
}

checkDirectoryPermissions()
{
	# directory doesnt exist:	rc=10
	# read allowed:			rc=4|5|6|7
	# write allowed:		rc=2|3|6|7
	# execute allowed:		rc=1|3|5|7

	local directory="${1:-}"
	local rc=
	local directory_permission=

	checkDirectoryExists "${directory}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		if [ -x "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0001))"
		fi

		if [ -w "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0010))"
		fi

		if [ -r "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0100))"
		fi
	else
		directory_permission="$((2#1010))"
	fi

	return "${directory_permission}"
}

setDefaultValues()
{
	log_file_full_path="${log_directory}${log_filename}"
	backup_full_path="${backup_destination_path}${backup_filename}"
	backup_encryption_filename="${backup_full_path//tar.gz/aes.tar.gz}"
}

checkRootPrivileges()
{
	logHandler "Check if root priviliges are required..."

	if [ "${root_privileges_required}" == "1" ] ;then
		logHandler "Root privileges are required, checking privileges..."

		if [ "$UID" == "0" ] ;then
			logHandler "HOORAY, we have root privileges. :)"
		else
			logHandler "You must run this script as root, terminating."
			script_exit_code="50"
			exit
		fi
	else
		logHandler "Root privileges are not required..."
	fi
}

getUser()
{
	local rc=
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ ! -z "${SUDO_USER:-}" ] ;then
		script_exec_user="$SUDO_USER"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started by user: '${script_exec_user}'."
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ] ;then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="60"
		exit
	else
		case "${BASH_VERSINFO[0]}" in
					3|4)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
						;;
					*)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."
						script_exit_code="61"
						exit
						;;
		esac
	fi
}

checkAlreadyRunningInstance()
{
	local rc=
	local running_script_pids=

	# shellcheck disable=SC2154
	running_script_pids="$(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_name}(.*)$")"
	running_script_pids="${running_script_pids//${script_pid}/}"

	# shellcheck disable=SC2154
	running_script_pids="${running_script_pids//$(${pgrep_bin} -d " " -P "${script_pid}")/}"
	running_script_pids="${running_script_pids//\ /\,\ }"

	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="$?"

	if ([ "${rc}" != "0" ] && [ -z "${running_script_pids:-}" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "${rc}" == "0" ] && [ -z "${running_script_pids:-}" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."

		if [ "${script_override_lock}" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-o'."

			script_another_instance_is_running="1"
			script_exit_code="70"
			exit
		fi
	elif ([ "${rc}" == "0" ] && [ ! -z "${running_script_pids:-}" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"

		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="71"
		exit
	elif ([ "${rc}" != "0" ] && [ ! -z "${running_script_pids:-}" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"

		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="72"
		exit
	fi
}

reNice()
{
	logHandler "Check if re-niceing is enabled..."

	if [ "${re_nice_enabled}" == "1" ] ;then
		logHandler "Re-niceing is enabled."
		logHandler "Check if renice priority is in range..."

		if ([ "${re_nice_priority}" -lt "-20" ] || [ "${re_nice_priority}" -gt "19" ]) ;then
			logHandler "Re-nice priority: '${re_nice_priority}' is out of range."
			logHandler "HINT: Have a look at: 'man renice'."

			script_exit_code="80"
			exit
		else
			logHandler "Re-nice priority: '${re_nice_priority}' is in range."
			logHandler "Re-niceing..."

			# shellcheck disable=SC2154
			${renice_bin} -n ${re_nice_priority} -p ${script_pid} 2>&1 | logHandler
			
			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Re-niceing was successful."
			else
				logHandler "Re-niceing was not successful."
				script_exit_code="81"
				exit
			fi
		fi
	else
		logHandler "Re-niceing is not enabled."
	fi
}

reIONice()
{
	local re_ionice_cmd=
	local re_ionice_priority_required=

	logHandler "Check if re-ioniceing is enabled..."

	if [ "${re_ionice_enabled}" == "1" ] ;then
		logHandler "Re-ioniceing is enabled."
		logHandler "Check if re-ioniceing parameters are in range..."

		if ([ "${re_ionice_scheduling_class}" -gt "3" ] || [ "${re_ionice_scheduling_class}" -lt "1" ]) ;then
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is out of range."
			logHandler "HINT: Have a look at: 'man ionice'."

			script_exit_code="90"
			exit
		else
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is in range."
		fi

		if ([ "${re_ionice_scheduling_class}" == "1" ] || [ "${re_ionice_scheduling_class}" == "2" ]) ;then
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' requires re-ioniceing priority."
			logHandler "Check if re-ioniceing priority is in range..."

			re_ionice_priority_required="1"

			if ([ "${re_ionice_priority}" -gt "7" ] || [ "${re_ionice_priority}" -lt "0" ]) ;then
				logHandler "Re-ioniceing priority: '${re_ionice_priority}' is out of range."
				logHandler "HINT: Have a look at: 'man ionice'."

				script_exit_code="91"
				exit
			else
				logHandler "Re-ioniceing priority: '${re_ionice_scheduling_class}' is in range."
			fi
		else
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' does not require a re-ioniceing priority."
		fi

		logHandler "Re-ioniceing..."

		if [ "${re_ionice_priority_required}" == "1" ] ;then
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -n ${re_ionice_priority} -p ${script_pid}"
		else
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -p ${script_pid}"
		fi

		${re_ionice_cmd}  2>&1 | logHandler
		
		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Re-ioniceing was successful."
		else
			logHandler "Re-ioniceing was not successful."
			script_exit_code="92"
			exit
		fi
	else
		logHandler "Re-ioniceing is not enabled."
	fi
}

executePreBackupScript()
{
	local rc=

	logHandler "Check if pre backup script functionality is enabled..."

	if [ "${pre_backup_script_enabled}" == "1" ] ;then
		logHandler "Pre backup script functionality is enabled."
		logHandler "Check if pre backup script (${pre_backup_script}) exists and if it is executeable..."

		checkFilePermissions "${pre_backup_script}"
		rc="$?"

		case "${rc}" in
			1|3|5|7)
				logHandler "Pre backup script exists and it is executeable, so we execute it..."
				;;
			10)
				logHandler "Pre backup script doesnt exist, nothing to do."
				script_exit_code="100"
				exit
				;;
			*)
				logHandler "Pre backup script exists, but it is not executeable, nothing to do."
				script_exit_code="101"
				exit
				;;
		esac

		eval "${pre_backup_script} 2>&1" | logHandler
		rc="$?"

		if [ "${rc}" == "0" ] ;then
			logHandler "Execution of pre backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of pre backup script was unsuccessful. rc: '${rc}'."

			if [ "${pre_backup_exit_when_unsuccessful}" == "1" ] ;then
				logHandler "Breaking, because execution of pre backup script was unsuccessful und you want it."
				script_exit_code="102"
				exit
			fi
		fi
	else
		logHandler "Pre backup script functionality is not enabled."
	fi
}

rotateHandler()
{
	local rc=
	local file=
	local file_to_handle=
	local file_helper=

	logHandler "Check if backup rotation is enabled..."

	if [ "${backup_rotation_enabled}" == "1" ] ;then
		logHandler "Backup rotation is enabled."
		logHandler "Check if backup directory: '${backup_destination_path}' exists and permissions to move files are ok..."

		checkDirectoryPermissions "${backup_destination_path}"
		rc="$?"

		case "${rc}" in
			3|7)
				logHandler "Backup directory exists and permissions are ok."
				;;
			10)
				logHandler "Backup directory doesnt exist."
				logHandler "Creating backup directory..."

				# shellcheck disable=SC2154
				${mkdir_bin} -p "${backup_destination_path}" 2>&1 | logHandler

				if [ "${PIPESTATUS[0]}" == "0" ] ;then
					logHandler "Creating backup directory was successful."
				else
					logHandler "Creating backup directory was not successful."
					script_exit_code="110"
					exit
				fi
				;;
			*)
				logHandler "Backup directory exists but permissions are not ok, exiting."
				script_exit_code="111"
				exit
				;;
		esac

		if [ "${backup_encryption_enabled}" == "1" ] ;then
			file="${backup_encryption_filename}"
		else
			file="${backup_full_path}"
		fi

		backup_rotation_files_to_keep=$((backup_rotation_files_to_keep - 1))
		
		logHandler "Rotating backup files..."

		while [ "${backup_rotation_files_to_keep}" -gt "0" ]
		   do
			file_helper=$((backup_rotation_files_to_keep - 1))

			if [ "${backup_rotation_files_to_keep}" != "1" ] ;then
				file_to_handle="${file}.${file_helper}"
			else
				file_to_handle="${file}"
			fi

			logHandler "Check if file: '${file_to_handle}' exists and if it is readable..."

			checkFilePermissions "${file_to_handle}"
			rc="$?"

			case "${rc}" in
				4|5|6|7)
					logHandler "File exists and is readable, do rotation..."

					# shellcheck disable=SC2154
					${mv_bin} "${file_to_handle}" "${file}.${backup_rotation_files_to_keep}" 2>&1 | logHandler

					if [ "${PIPESTATUS[0]}" == "0" ] ;then
						logHandler "Rotating file: '${file_to_handle}' ==> '${file}.${backup_rotation_files_to_keep}' was successful."
					else
						logHandler "Rotating file: '${file_to_handle}' ==> '${file}.${backup_rotation_files_to_keep}' was not successful."
					fi
					;;
				10)
					logHandler "File doesnt exist, nothing to do."
					;;
				*)
					logHandler "File exists but is not readable."
					script_exit_code="112"
					exit
					;;
			esac

			backup_rotation_files_to_keep=$((backup_rotation_files_to_keep - 1))

		   done
	else
		logHandler "Backup rotation is not enabled."
	fi
}

createInstalledPackagesFile()
{
	local rc=
	local syspackage_manager=
	local available_syspackage_managers_helper=

	logHandler "Check if installed packages are enabled..."

	if [ "${installed_packages_enabled}" == "1" ] ;then
		logHandler "Installed packages are enabled."

		if [ "${#available_syspackage_managers[*]}" -gt "1" ] ;then
			available_syspackage_managers_helper="${available_syspackage_managers[*]}"
			available_syspackage_managers_helper="${available_syspackage_managers_helper//\ /\,\ }"

			logHandler "More than one supported syspackage managers found: '${available_syspackage_managers_helper}', dont know what to do, exiting."

			if [ -z "${installed_packages_forced_manager}" ] ;then
				logHandler "HINT: You can force to use one of the supported syspackage managers by setting configuration variable: 'installed_packages_forced_manager'."
			fi

			script_exit_code="120"
			exit
		elif [ "${#available_syspackage_managers[*]}" -eq "1" ] ;then
			syspackage_manager="${available_syspackage_managers[*]}"
			logHandler "The supported system package manager we found is: '${syspackage_manager}'."
		elif [ "${#available_syspackage_managers[*]}" -eq "0" ] ;then
			logHandler "No supported system package manager found, exiting."
			script_exit_code="121"
			exit
		fi

		logHandler "Creating installed packages file: '${installed_packages_filename}'..."

		case "${syspackage_manager}" in
						rpm)
							${syspackage_manager} -qa > "${installed_packages_filename}"
							;;
						dpkg)
							${syspackage_manager} --get-selections > "${installed_packages_filename}"
							;;
						pacman)
							${syspackage_manager} -Qqe > "${installed_packages_filename}"
							;;
						equery)
							${syspackage_manager} list "*" > "${installed_packages_filename}"
							;;
						pkgutil)
							${syspackage_manager} --pkgs > "${installed_packages_filename}"
							;;
						*)
							logHandler "Unsupported syspackage manager used in function: '${FUNCNAME[0]}'. :( Exiting."
							script_exit_code="122"
							exit
							;;
		esac

		rc="$?"

		if [ "${rc}" == "0" ] ;then
			logHandler "Creating installed packages file was successful, adding file to backup_items config array."
			backup_items+=("${installed_packages_filename}")
		else
			logHandler "Creating installed packages file was not successful."
			script_exit_code="123"
			exit
		fi
	else
		logHandler "Installed packages are not enabled..."
	fi
}

buildExcludeOpts()
{
	local rc=

	logHandler "Check if we need to build excluding options..."

	if [ ! -z "${backup_exlude_items[*]:-}" ] ;then
		logHandler "Building of excluding options is enabled."
		exclude_string=()

		for item in "${backup_exlude_items[@]}"
		   do
			exclude_string+=("--exclude='${item}'")
		   done

		logHandler "We build the following excluding options: '${exclude_string[*]}'."
	else
		logHandler "We dont have to build excluding options..."
	fi
}

buildBackupOpts()
{
	logHandler "Building backup options..."

	backup_options=("--create" "--file=${backup_full_path}")

	if [ "${backup_compression_enabled}" == "1" ] ;then
		case "${backup_compression_type}" in
							gzip)
								backup_options+=("--gzip")
								;;
							bzip2)
								backup_options+=("--bzip2")
								;;
							xz)
								backup_options+=("--xz")
								;;
							lzip)
								backup_options+=("--lzip")
								;;
							lzma)
								backup_options+=("--lzma")
								;;
							lzop)
								backup_options+=("--lzop")
								;;
							*)
								logHandler "Unsupported compression type configured, exiting."
								script_exit_code="130"
								exit
								;;
		esac
	fi

	if [ "${backup_verbose_mode_enabled}" == "1" ] ;then
		backup_options+=("--verbose")
	fi

	logHandler "We build the following backup options: '${backup_options[*]}'."
}

makeBackup()
{
	local backup_cmd=

	if [ -z "${exclude_string[*]:-}" ] ;then
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${backup_options[*]} ${backup_items[*]}"
	else
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${backup_options[*]} ${backup_items[*]} ${exclude_string[*]}"
	fi

	logHandler "Starting backup job..."

	${backup_cmd} 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Backup job was successful."
		script_exit_code="0"
	else
		logHandler "Backup job was not successful."
		script_exit_code="140"
		exit
	fi
}

encryptBackup()
{
	if [ "${backup_encryption_enabled}" == "1" ] ;then
		logHandler "Backup encryption is enabled..."
		logHandler "Encrypting backup file: '${backup_full_path}'..."

		# shellcheck disable=SC2154
		${openssl_bin} aes-256-cbc -salt -in "${backup_full_path}" -out "${backup_encryption_filename}" -k "${backup_encryption_password}" 2>&1 | logHandler

		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Encrypting job was successful."
			logHandler "HINT: To decrypt use this command: '${openssl_bin} aes-256-cbc -d -salt -in ${backup_encryption_filename} -out ${backup_full_path}'."
			script_exit_code="0"
		else
			logHandler "Encrypting job was not successful."
			script_exit_code="150"
			exit
		fi
	else
		logHandler "Backup encryption is not enabled..."
	fi
}

executePostBackupScript()
{
	local rc=

	logHandler "Check if post backup script functionality is enabled..."

	if [ "${post_backup_script_enabled}" == "1" ] ;then
		logHandler "Post backup script functionality is enabled."
		logHandler "Check if post backup script (${post_backup_script}) exists and if it is executeable..."

		checkFilePermissions "${post_backup_script}"
		rc="$?"

		case "${rc}" in
			1|3|5|7)
				logHandler "Post backup script exists and it is executeable, so we execute it..."
				;;
			10)
				logHandler "Post backup script doesnt exist, nothing to do."
				script_exit_code="160"
				exit
				;;
			*)
				logHandler "Post backup script exists, but it is not executeable, nothing to do."
				script_exit_code="161"
				exit
				;;
		esac

		eval "${post_backup_script} 2>&1" | logHandler
		rc="$?"

		if [ "${rc}" == "0" ] ;then
			logHandler "Execution of post backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of post backup script was unsuccessful. rc: '${rc}'."

			if [ "${post_backup_exit_when_unsuccessful}" == "1" ] ;then
				logHandler "Breaking, because execution of post backup script was unsuccessful und you want it."
				script_exit_code="162"
				exit
			fi
		fi
	else
		logHandler "Post backup script functionality is not enabled."
	fi
}



#-------
# Start:
#-------

checkRequiredBinaries



#-------------
# Get options:
#-------------

OPTERR="0"

while getopts ":hov" OPTION
   do
	logHandler "Getting options..."

	case "$OPTION" in
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="170"
				exit
				;;
			o)
				script_override_lock="1"
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="171"
				exit
				;;
			\?)
				logHandler "Invalid option: -${OPTARG}"
				printUsage
				script_exit_code="172"
				exit
				;;
			:)
				logHandler "Option: -${OPTARG} requires an argument."
				printUsage
				script_exit_code="173"
				exit
				;;
	esac
   done



#------
# Main:
#------

setDefaultValues
checkRootPrivileges
getUser
checkBashVersion
checkAlreadyRunningInstance
reNice
reIONice
executePreBackupScript
rotateHandler
createInstalledPackagesFile
buildExcludeOpts
buildBackupOpts
makeBackup
encryptBackup
executePostBackupScript

exit



#-------------------------
# Should never be reached:
#-------------------------

logHandler "Ooops!!! Something went terribly wrong... :( Exiting."
exit
