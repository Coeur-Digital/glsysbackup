#!/usr/bin/env bash

#########################################################################################################
#
#  Author:	ccztux
#		2017-02-04
#
#  Last Mod:	ccztux
#		2017-02-05
#
#  Description:	Generic Linux System Backup
#
#  Changelog:	1.0.0.a Initial revision
#
#  TODO:	-
#
#  License:	GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#########################################################################################################


trap 'sigHandler SIGTERM' SIGTERM
trap 'sigHandler SIGINT' SIGINT
trap 'sigHandler SIGHUP' SIGHUP
trap 'sigHandler SIGABRT' SIGABRT
trap 'sigHandler SIGQUIT' SIGQUIT
trap 'sigHandler ERR ${LINENO} ${BASH_COMMAND}' ERR
trap 'sigHandler EXIT' EXIT


#-----------------------
# Script info variables:
#-----------------------

script_name="${0##*/}"
script_version="1.0.0.a"
script_argc="$#"
script_pid="$$"
script_exit_code="200"
script_start_time="`date +%s`"
script_lock_file="/var/lock/${script_name}"
script_hostname="${HOSTNAME%%.*}"
script_author="ccztux"
script_last_mod="2017-02-05"
script_description="Generic Linux System Backup"



#-------------------------
# Configuration variables:
#-------------------------

backup_path="/var/backups/"
filename="system.${script_hostname}.bak_${script_start_time}.tar.gz"
full_backup_path="${backup_path}${filename}"
installed_packages="/root/installed_packages.txt"
items_to_backup="/etc/ /home/ /root/ /var/lib/mpd/ /usr/local/bin/ /usr/lib/cgi-bin/ /boot/config.txt"
items_to_exclude=("")
backup_cmd="tar -cvzf ${full_backup_path} ${items_to_backup}"

log_to_syslog="1"
log_to_file="0"
log_file="/var/log/${script_name}.log"
log_to_stdout="1"


#-----------
# Functions:
#-----------

getUser()
{
	logHandler "Get user which starts the script..."
	if [ $SUDO_USER ] ;then
		script_exec_user="$SUDO_USER"
	else
		script_exec_user="`whoami`"
	fi
	logHandler "${script_name} was started by: '${script_exec_user}'."
}

checkLock()
{
	local rc=
	logHandler "Check if lock file: '${script_lock_file}' exists."
	checkLocalFileExists "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Lock file: '${script_lock_file}' exist."
		return 0
	else
		logHandler "Lock file: '${script_lock_file}' doesnt exist."
		return 1
	fi
}

setLock()
{
	local rc=
	logHandler "Setting lock..."
	echo "$script_pid" > "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful."
		script_exit_code="10"
		exit
	fi
}

checkAlreadyRunningInstance()
{
	logHandler "Check if another instance of: '${script_name}' is already running..."
	local rc=
	local running_script_pids="`pgrep $script_name`"
	running_script_pids="${running_script_pids//${script_pid}/}"
	running_script_pids="${running_script_pids//$'\n'/, }"
	checkLock
	rc="$?"
	if ([ "$rc" != "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "$rc" == "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		if [ "$override_lock" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-l'."
			another_instance_is_running="1"
			script_exit_code="20"
			exit
		fi
	elif ([ "$rc" == "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="21"
		exit
	elif ([ "$rc" != "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="22"
		exit
	fi
}

removeLock()
{
	local rc=
	logHandler "Removing lock..."
	rm "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="30"
		exit
	fi
}

overrideLock()
{
	logHandler "Override lock, because you want it..."
	removeLock
	setLock
}

checkLocalFileExists()
{
	local file="$1"
	if [ -f "$file" ] ;then
		if [ -s "$file" ] ;then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

cleanOldBackups()
{
	for backup in ${backup_path}system.`hostname`.bak_*
	   do
		if [ "$backup" != "$full_backup_path" ] ;then
			rm "${backup}" 2>&1 | logHandler
		fi
	   done
}

checkTrailingSlash()
{
	local path="$1"
	if [[ "$path" =~ ^.*\/$ ]] ;then
		removeLastChar "$path"
	fi
}

removeLastChar()
{
	local string="$1"
	echo "${string:0:$((${#string} - 1))}"
}

getSysPackageManager()
{
	local dpkg="`which dpkg 2> /dev/null`"
	local rpm="`which rpm 2> /dev/null`"
	if [ ! -z "$dpkg" ] ;then
		syspackage_manager="$dpkg"
		${syspackage_manager} --get-selections > $installed_packages
	elif [ ! -z "$rpm" ] ;then
		syspackage_manager="$rpm"
		${syspackage_manager} -qa > $installed_packages
	fi
}

buildExcludeOpts()
{
	if [ ! -z "${items_to_exclude[*]}" ] ;then
		for item in ${items_to_exclude[*]}
		   do
			exclude_string="${exclude_string} --exclude='`checkTrailingSlash ${item}`'"
		   done
	else
		return 0
	fi
}

logHandler()
{
	local log_message="${1//\`/}"
	local log_timestamp=
	local stdin_data_available=
	if [ -z "$log_message" ] ;then
		if [ -t 0 ] ;then
			stdin_data_available="0"
		else
			stdin_data_available="1"
		fi
		if [ "$stdin_data_available" == "1" ] ;then
			logHandlerStdinHelper
		fi
	else
		if [ "$log_to_syslog" == "1" ];then
			logger -t "${script_name}[${script_pid}]" "${log_message}"
		fi
		if [ "$log_to_file" == "1" ];then
			log_timestamp="`date '+%Y-%m-%d %H:%M:%S'`"
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}" >> ${log_file}
		fi
		if [ "$log_to_stdout" == "1" ] ;then
			if [ -z "$log_timestamp" ] ;then
				log_timestamp="`date '+%Y-%m-%d %H:%M:%S'`"
			fi
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}"
		fi
	fi
}

logHandlerStdinHelper()
{
	while read stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

sigHandler()
{
	local signal="$1"
	local lineno="$2"
	local bash_command="$3"
	local rc=
	case "$signal" in
		SIGTERM)
			logHandler "Caught SIGTERM, preparing for exiting script..."
			script_exit_code="40"
			exit
			;;
		SIGINT)
			logHandler "Caught SIGINT, preparing for exiting script..."
			script_exit_code="41"
			exit
			;;
		SIGHUP)
			logHandler "Caught SIGHUP, preparing for exiting script..."
			script_exit_code="42"
			exit
			;;
		SIGABRT)
			logHandler "Caught SIGABRT, preparing for exiting script..."
			script_exit_code="43"
			exit
			;;
		SIGQUIT)
			logHandler "Caught SIGQUIT, preparing for exiting script..."
			script_exit_code="44"
			exit
			;;
		ERR)
			logHandler "Caught ERR, at line number: '${lineno}', command: '${bash_command}'. Preparing for exiting script..."
			script_exit_code="45"
			exit
			;;
		EXIT)
			logHandler "Caught EXIT, preparing for exiting..."
			logHandler "Killing child processes..."
			kill -- -${script_pid} 2>&1 | logHandler
			rc="${PIPESTATUS[0]}"
			if [ "$rc" == "0" ] ;then
				logHandler "Killing child processes was successful."
			else
				logHandler "Killing child processes was not successful, but we did this only as a precaution."
			fi
			if [ "$another_instance_is_running" != "1" ] ;then
				removeLock
			fi
			logHandler "Script was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."
			kill 0
			;;
		*)
			logHandler "Signal: '${signal}' received in function: '$FUNCNAME' but dont know what to do..."
			;;
	esac
}

makeBackup()
{
	logHandler "Starting backup job..."
	local rc=
	eval "${backup_cmd} ${exclude_string} 2>&1" | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup job was successful."
		logHandler "We did a great job, initiating termination..."
		script_exit_code="0"
		exit
	else
		logHandler "Backup job was not successful."
	fi
}



#------
# Main:
#------

logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
getUser
checkAlreadyRunningInstance
cleanOldBackups
getSysPackageManager
buildExcludeOpts
makeBackup

logHandler "Ooops! Something went terribly wrong... Exiting..."
exit
