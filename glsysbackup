#!/bin/bash

#########################################################################################################
#
#  Author:	Christian Zettel (ccztux)
#		2017-02-04
#		Copyright Â© 2017 Christian Zettel (cczux), all rights reserved
#		http://linuxinside.at
#
#  Last Mod:	Christian Zettel (ccztux)
#		2017-02-06
#
#  Description:	Generic Linux System Backup
#
#  Changelog:	1.0.0.b Initial revision
#
#  TODO:	-
#
#  License:	GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#########################################################################################################


trap 'sigHandler SIGTERM' SIGTERM
trap 'sigHandler SIGINT' SIGINT
trap 'sigHandler SIGHUP' SIGHUP
trap 'sigHandler SIGABRT' SIGABRT
trap 'sigHandler SIGQUIT' SIGQUIT
trap 'sigHandler ERR ${LINENO} ${BASH_COMMAND}' ERR
trap 'sigHandler EXIT' EXIT


#-----------------------
# Script info variables:
#-----------------------

script_name="${0##*/}"
script_version="1.0.0.b"
script_author="ccztux"
script_last_mod="2017-02-06"
script_description="Generic Linux System Backup"
script_start_time="`date +%s`"
script_argc="$#"
script_pid="$$"
script_exit_code="255"
script_lock_file="/var/lock/${script_name}"
script_hostname="${HOSTNAME%%.*}"
script_major_bashversion="${BASH_VERSINFO[0]}"




#-------------------------
# Configuration variables:
#-------------------------

backup_path="/var/backups/"
filename="${script_name}.${script_hostname}.tar.gz"
full_backup_path="${backup_path}${filename}"
installed_packages="/root/installed_packages.txt"
items_to_backup="/home/ /root/ /var/lib/mpd/ /usr/local/bin/ /boot/config.txt"
items_to_exclude=("/root/old" "/tmp/var")
backup_cmd="tar -cvzf ${full_backup_path} ${items_to_backup}"
encrypt_backup="1"
backup_password="test1234"
encrypted_backup_filename="${full_backup_path//tar.gz/aes.tar.gz}"

log_to_syslog="1"
log_to_file="0"
log_file="/var/log/${script_name}.log"
log_to_stdout="1"


#-----------
# Functions:
#-----------

checkUID()
{
	logHandler "Checking privileges..."
	if [ "$UID" != "0" ] ;then
		logHandler "You must run this script as root, terminating..."
		script_exit_code="10"
		exit
	fi
}

checkBashVersion()
{
	logHandler "Checking bash version..."
	case "$script_major_bashversion" in
				3)
					logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
					;;
				4)
					logHandler "Bash version: '${script_major_bashversion}' meets requirements..."
					;;
				*)
					logHandler "Bash version: '${script_major_bashversion}' doenst meets requirements, terminating..."
					script_exit_code="20"
					exit
					;;
	esac
}

getUser()
{
	logHandler "Get user which starts the script..."
	if [ $SUDO_USER ] ;then
		script_exec_user="$SUDO_USER"
	else
		script_exec_user="`whoami`"
	fi
	logHandler "${script_name} was started by: '${script_exec_user}'."
}

checkLock()
{
	local rc=
	logHandler "Check if lock file: '${script_lock_file}' exists."
	checkLocalFileExists "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Lock file: '${script_lock_file}' exist."
		return 0
	else
		logHandler "Lock file: '${script_lock_file}' doesnt exist."
		return 1
	fi
}

setLock()
{
	local rc=
	logHandler "Setting lock..."
	echo "$script_pid" > "$script_lock_file"
	rc="$?"
	if [ "$rc" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful."
		script_exit_code="30"
		exit
	fi
}

checkAlreadyRunningInstance()
{
	logHandler "Check if another instance of: '${script_name}' is already running..."
	local rc=
	local running_script_pids="`pgrep $script_name`"
	running_script_pids="${running_script_pids//${script_pid}/}"
	running_script_pids="${running_script_pids//$'\n'/, }"
	checkLock
	rc="$?"
	if ([ "$rc" != "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "$rc" == "0" ] && [ -z "$running_script_pids" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		if [ "$override_lock" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-l'."
			another_instance_is_running="1"
			script_exit_code="40"
			exit
		fi
	elif ([ "$rc" == "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="41"
		exit
	elif ([ "$rc" != "0" ] && [ ! -z "$running_script_pids" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."
		another_instance_is_running="1"
		script_exit_code="42"
		exit
	fi
}

removeLock()
{
	local rc=
	logHandler "Removing lock..."
	rm "$script_lock_file" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="50"
		exit
	fi
}

overrideLock()
{
	logHandler "Override lock, because you want it..."
	removeLock
	setLock
}

checkLocalFileExists()
{
	local file="$1"
	if [ -f "$file" ] ;then
		if [ -s "$file" ] ;then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

checkBin()
{
	local binary="$1"
	local rc=
	if [ -z "$binary" ] ;then
		logHandler "Function: '${FUNCNAME}' called without required argument, nothing to do, exiting..."
		script_exit_code="112"
		exit
	else
		logHandler "Check if binary '${binary}' exists."
		export ${binary}_bin="`which \"${binary}\" 2>&1`"
		rc="$?"
		if [ "$rc" == "0" ] ;then
			logHandler "Binary: '${binary}' found."
			return 0
		else
			logHandler "Binary: '${binary}' not found, exiting..."
			script_exit_code="111"
			exit
		fi
	fi
}

checkTrailingSlash()
{
	local path="$1"
	if [[ "$path" =~ ^.*\/$ ]] ;then
		removeLastChar "$path"
	else
		echo "$path"
	fi
}

removeLastChar()
{
	local string="$1"
	echo "${string:0:$((${#string} - 1))}"
}

getSysPackageManager()
{
	local supported_syspackage_managers=("rpm" "dpkg")
	local available_syspackage_managers=()
	for syspackman in ${supported_syspackage_managers[*]}
	   do
		available_syspackage_managers+=("`checkBin \"$syspackman\"`")
	   done
	if [ "${#available_syspackage_managers[*]}" -gt "1" ] ;then
		logHandler "More than one supported syspackage managers found: '${available_syspackage_managers[*]}', dont know what to do..."
		return 1
	else
		case "${available_syspackage_managers}" in
							rpm)
								${rpm_bin} -qa > $installed_packages
								;;
							dpkg)
								${dpkg_bin} --get-selections > $installed_packages
								;;
							*)
								;;
		esac
	fi
}

buildExcludeOpts()
{
	if [ ! -z "${items_to_exclude[*]}" ] ;then
		logHandler "Building exclude options..."
		exclude_string=()
		for item in ${items_to_exclude[*]}
		   do
			exclude_string+=("--exclude='`checkTrailingSlash \"${item}\"`'")
		   done
		logHandler "We build the following exclude options: '${exclude_string[*]}'."
	else
		return 0
	fi
}

rotateHandler()
{
	logHandler "Rotating backup files..."
	local rc=
	local files_to_keep="$1"
	if [ -z "$files_to_keep" ] ;then
		local files_to_keep="5"
	fi
	if [ "$encrypt_backup" == "1" ] ;then
		file="$encrypted_backup_filename"
	else
		file="$full_backup_path"
	fi
	files_to_keep=$(($files_to_keep - 1))
	while [ "$files_to_keep" -gt "0" ]
	   do
		local file_helper=$(($files_to_keep - 1))
		if [ "$files_to_keep" != "1" ] ;then
			checkLocalFileExists "${file}.${file_helper}"
			rc="$?"
			if [ "$rc" == "0" ] ;then
				mv ${file}.${file_helper} ${file}.${files_to_keep} 2>&1 | logHandler
				rc="${PIPESTATUS[0]}"
				if [ "$rc" == "0" ] ;then
					logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${files_to_keep}' was successful."
				else
					logHandler "Rotating file: '${file}.${file_helper}' ==> '${file}.${files_to_keep}' was not successful."
				fi
			fi
		else
			checkLocalFileExists "${file}"
			rc="$?"
			if [ "$rc" == "0" ] ;then
				mv ${file} ${file}.${files_to_keep} 2>&1 | logHandler
				rc="${PIPESTATUS[0]}"
				if [ "$rc" == "0" ] ;then
					logHandler "Rotating file: '${file}' ==> '${file}.${files_to_keep}' was successful."
				else
					logHandler "Rotating file: '${file}' ==> '${file}.${files_to_keep}' was not successful."
				fi
			fi
		fi
		files_to_keep=$(($files_to_keep - 1))
	   done
}

logHandler()
{
	local log_message="${1//\`/}"
	local log_timestamp=
	local stdin_data_available=
	if [ -z "$log_message" ] ;then
		if [ -t "0" ] ;then
			stdin_data_available="0"
		else
			stdin_data_available="1"
		fi
		if [ "$stdin_data_available" == "1" ] ;then
			logHandlerStdinHelper
		fi
	else
		if [ "$log_to_syslog" == "1" ];then
			logger -t "${script_name}[${script_pid}]" "${log_message}"
		fi
		if [ "$log_to_file" == "1" ];then
			log_timestamp="`date '+%Y-%m-%d %H:%M:%S'`"
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}" >> ${log_file}
		fi
		if [ "$log_to_stdout" == "1" ] ;then
			if [ -z "$log_timestamp" ] ;then
				log_timestamp="`date '+%Y-%m-%d %H:%M:%S'`"
			fi
			echo -e "[${log_timestamp}] ${script_name}: [${script_pid}] ${log_message}"
		fi
	fi
}

logHandlerStdinHelper()
{
	while read stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

sigHandler()
{
	local signal="$1"
	local lineno="$2"
	local bash_command="$3"
	local rc=
	case "$signal" in
		SIGTERM)
			logHandler "Caught SIGTERM, preparing for exiting script..."
			script_exit_code="60"
			exit
			;;
		SIGINT)
			logHandler "Caught SIGINT, preparing for exiting script..."
			script_exit_code="61"
			exit
			;;
		SIGHUP)
			logHandler "Caught SIGHUP, preparing for exiting script..."
			script_exit_code="62"
			exit
			;;
		SIGABRT)
			logHandler "Caught SIGABRT, preparing for exiting script..."
			script_exit_code="63"
			exit
			;;
		SIGQUIT)
			logHandler "Caught SIGQUIT, preparing for exiting script..."
			script_exit_code="64"
			exit
			;;
		ERR)
			logHandler "Caught ERR, at line number: '${lineno}', command: '${bash_command}'. Preparing for exiting script..."
			script_exit_code="65"
			exit
			;;
		EXIT)
			logHandler "Caught EXIT, preparing for exiting..."
			if [ "$another_instance_is_running" != "1" ] ;then
				removeLock
			fi
			logHandler "Script was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."
			exit $script_exit_code
			;;
		*)
			logHandler "Signal: '${signal}' received in function: '$FUNCNAME' but dont know what to do..."
			;;
	esac
}

makeBackup()
{
	logHandler "Starting backup job..."
	local rc=
	eval "${backup_cmd} ${exclude_string} 2>&1" | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Backup job was successful."
		if [ "$encrypt_backup" == "1" ] ;then
			encryptBackup
		else
			logHandler "We did a great job, initiating termination..."
			script_exit_code="0"
			exit
		fi
	else
		logHandler "Backup job was not successful."
		script_exit_code="70"
		exit
	fi
}

encryptBackup()
{
	logHandler "Encrypting backup file: '${full_backup_path}'..."
	logHandler "HINT: You can use the following command, to decrypt your backup: 'openssl aes-256-cbc -d -salt -in ${encrypted_backup_filename} -out ${full_backup_path}'."
	local rc=
	openssl aes-256-cbc -salt -in ${full_backup_path} -out ${encrypted_backup_filename} -k ${backup_password} 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Encrypting job was successful."
		delUnencryptedBackupFile
	else
		logHandler "Encrypting job was not successful."
		script_exit_code="80"
		exit
	fi
}

delUnencryptedBackupFile()
{
	logHandler "Deleting unencrypted backup file: '${full_backup_path}'..."
	local rc=
	rm "${full_backup_path}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"
	if [ "$rc" == "0" ] ;then
		logHandler "Deleting of unencrypted backup file: '${full_backup_path}' was successful."
		logHandler "We did a great job, initiating termination..."
		script_exit_code="0"
		exit
	else
		logHandler "Deleting of unencrypted backup file: '${full_backup_path}' was not successful."
		script_exit_code="90"
		exit
	fi
}



#------
# Main:
#------

logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
checkAlreadyRunningInstance
checkUID
getUser
checkBashVersion
rotateHandler
getSysPackageManager
buildExcludeOpts
makeBackup

logHandler "Ooops! Something went terribly wrong... Exiting..."
exit
