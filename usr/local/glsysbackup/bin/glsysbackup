#!/usr/bin/env bash

#========================================================================================================
#
#  Author:		Christian Zettel (ccztux)
#			2017-02-04
#			http://linuxinside.at
#
#  Copyright:		Copyright © 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:	https://github.com/ccztux/glsysbackup
#
#  Last Modification:	Christian Zettel (ccztux)
#			2018-01-06
#
#  Description:		Generic Linux System Backup is an advanced backup tool written in bash.
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#========================================================================================================


#--------------
# Bash options:
#--------------

set -o noclobber || { printf "Setting essential bash option: 'noclobber' was not successful, terminating...\\n" ; exit 245 ; }
set -o nounset || { printf "Setting essential bash option: 'nounset' was not successful, terminating...\\n" ; exit 246 ; }
set -o pipefail || { printf "Setting essential bash option: 'pipefail' was not successful, terminating...\\n" ; exit 247 ; }



#-------
# Traps:
#-------

trap 'sigHandler SIGTERM' SIGTERM || { printf "Setting essential trap for signal: 'SIGTERM' was not successful, terminating...\\n" ; exit 248 ; }
trap 'sigHandler SIGINT' SIGINT || { printf "Setting essential trap for signal: 'SIGINT' was not successful, terminating...\\n" ; exit 249 ; }
trap 'sigHandler SIGHUP' SIGHUP || { printf "Setting essential trap for signal: 'SIGHUP' was not successful, terminating...\\n" ; exit 250 ; }
trap 'sigHandler SIGABRT' SIGABRT || { printf "Setting essential trap for signal: 'SIGABRT' was not successful, terminating...\\n" ; exit 251 ; }
trap 'sigHandler SIGQUIT' SIGQUIT || { printf "Setting essential trap for signal: 'SIGQUIT' was not successful, terminating...\\n" ; exit 252 ; }
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR || { printf "Setting essential trap for signal: 'ERR' was not successful, terminating...\\n" ; exit 253 ; }
trap 'sigHandler EXIT' EXIT || { printf "Setting essential trap for signal: 'EXIT' was not successful, terminating...\\n" ; exit 254 ; }



#-----------------------
# Script info variables:
#-----------------------

script_pid="${BASHPID}"
script_name="${0##*/}"
script_version="2.0.0-alpha1"
script_author="Christian Zettel (ccztux)"
script_copyright="Copyright © 2017 ${script_author}, all rights reserved"
script_project_website="https://github.com/ccztux/glsysbackup"
script_last_modification_date="2018-01-06"
script_license="GNU GPLv3"
script_description="${script_name} (Generic Linux System Backup) is an advanced backup tool written in bash."
script_exit_code="255"
script_another_instance_is_running="0"
script_bypass_exit_routines="0"
script_shutdown_in_progress="0"
script_override_lock="0"



#-----------
# Functions:
#-----------

printUsage()
{
	setDefaultValues

	printf "Usage: %s OPTIONS\\n\\n" "${script_name}"
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "OPTIONS:\\n"
	printf "   -h\\t\\tShows this help.\\n"
	printf "   -c\\t\\tPath to config file. The file extension has to be: '.conf'. (If undefined, default value: '%s/etc/%s.conf' will be used.)\\n" "${script_base_path}" "${script_name}"
	printf "   -o\\t\\tOverride lock in case %s was terminated abnormally.\\n" "${script_name}"
	printf "   -v\\t\\tShows detailed version information.\\n"
}

printScriptInfos()
{
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Project website:\\t%s\\n" "${script_project_website}"
	printf "License:\\t\\t%s\\n\\n" "${script_license}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "Copyright:\\t\\t%s\\n" "${script_copyright}"
}

checkBin()
{
	local binary="${1:-}"
	local _bin=
	local rc=

	_bin="$(command -v "${binary}" 2>&1)"
	rc="${?}"

	if [ "${rc}" == "0" ] ;then
		export "${binary}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local rc=
	local bin=
	local syspackman=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=
	local supported_syspackage_managers=("rpm" "dpkg" "pacman" "equery" "pkgutil")

	if [ "${log_to_syslog}" == "1" ] ;then
		required_binaries+=("logger")
	fi

	if ([ "${log_to_file}" == "1" ] || [ "${log_to_stdout}" == "1" ]) ;then
		if ([ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]) ;then
			date_bin_printf="1"
			date_bin="printf"
		else
			required_binaries+=("date")
		fi
	fi

	if ([ "${backup_rotation_daily_enabled}" == "1" ] || [ "${backup_rotation_weekly_enabled}" == "1" ] || [ "${backup_rotation_monthly_enabled}" == "1" ]) ;then
		required_binaries+=("cp")
	fi

	if [ "${backup_encryption_enabled}" == "1" ] ;then
		required_binaries+=("openssl")
	fi

	if [ "${re_nice_enabled}" == "1" ] ;then
		required_binaries+=("renice")
	fi

	if [ "${re_ionice_enabled}" == "1" ] ;then
		required_binaries+=("ionice")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "tar" "mkdir" "kill")

	for bin in "${required_binaries[@]}"
	   do
		checkBin "${bin}"
		rc="${?}"

		if [ "${rc}" != "0" ] ;then
			binaries_not_found+=("${bin}")
		fi
	   done

	logHandlerSetConfig
	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
	logHandler "We are using config file: '${script_config_file}'."

	if [ "${#binaries_not_found[*]}" -gt "1" ] ;then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[*]}" -eq "1" ] ;then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi

	if [ "${installed_packages_enabled}" == "1" ] ;then
		available_syspackage_managers=()

		if [ -z "${installed_packages_forced_manager}" ] ;then
			for syspackman in "${supported_syspackage_managers[@]}"
			   do
				checkBin "${syspackman}"
				rc="${?}"

				if [ "${rc}" == "0" ] ;then
					available_syspackage_managers+=("${syspackman}")
				fi
			   done
		else
			checkBin "${installed_packages_forced_manager}"
			rc="${?}"

			if [ "${rc}" == "0" ] ;then
				available_syspackage_managers+=("${installed_packages_forced_manager}")
			fi
		fi

	fi
}

includeConfig()
{
	local rc=

	checkFileParameters "${script_config_file}"

	if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_regular_file_is_not_empty)) -gt "0" ] && [ $((file_permission & b_permission_read)) -gt "0" ]) ;then
		# shellcheck source=/scripts/usr/local/glsysbackup/etc/glsysbackup.conf
		source "${script_config_file}"
		rc="${?}"

		if [ "${rc}" == "0" ] ;then
			checkRequiredBinaries
		else
			printf "Including config file: '%s' was not successful, exiting.\\n" "${script_config_file}"
			script_bypass_exit_routines="1"
			script_exit_code="10"
			exit
		fi
	elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
		printf "Config file: '%s' does not exist, exiting.\\n" "${script_config_file}"
		script_bypass_exit_routines="1"
		script_exit_code="11"
		exit
	elif [ $((file_permission & b_regular_file_is_not_empty)) -eq "0" ] ;then
		printf "Config file: '%s' exists, but is empty, exiting.\\n" "${script_config_file}"
		script_bypass_exit_routines="1"
		script_exit_code="12"
		exit
	elif [ $((file_permission & b_permission_read)) -eq "0" ] ;then
		printf "Config file: '%s' exists, but it is not readable, exiting.\\n" "${script_config_file}"
		script_bypass_exit_routines="1"
		script_exit_code="13"
		exit
	fi
}

logHandlerSetConfig()
{
	log_file_full_path="${log_directory}${log_filename}"
	log_conf=
	b_log_to_file="1"
	b_log_to_stdout="2"
	b_log_to_syslog="4"
	b_date_bin_available="8"
	b_logger_bin_available="16"

	if [ "${date_bin_printf:-}" == "1" ] ;then
		date_cmd_format_prefix="'%("
		date_cmd_format_suffix=")T\\n'"
	else
		date_cmd_format_prefix="'+"
		date_cmd_format_suffix="'"
	fi

	if [ "${log_to_file}" == "1" ] ;then
		log_conf="$((log_conf | b_log_to_file))"
	fi

	if [ "${log_to_stdout}" == "1" ] ;then
		log_conf="$((log_conf | b_log_to_stdout))"
	fi

	if [ "${log_to_syslog}" == "1" ] ;then
		log_conf="$((log_conf | b_log_to_syslog))"
	fi

	if [ -n "${date_bin:-}" ] ;then
		log_conf="$((log_conf | b_date_bin_available))"
	fi

	if [ -n "${logger_bin:-}" ] ;then
		log_conf="$((log_conf | b_logger_bin_available))"
	fi
}

logHandlerStdinHelper()
{
	while read -r stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=

	if [ "${script_bypass_exit_routines}" == "1" ] ;then
		return
	fi

	if [ -z "${log_message:-}" ] ;then
		if [ ! -t "0" ] ;then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"

		if [ $((log_conf & b_log_to_stdout)) -gt "0" ] ;then
			if [ $((log_conf & b_date_bin_available)) -gt "0" ] ;then
				if [ -z "${log_timestamp}" ] ;then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
			else
				printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
			fi
		fi

		if [ $((log_conf & b_log_to_file)) -gt "0" ] ;then
			if [ $((log_conf & b_date_bin_available)) -gt "0" ] ;then
				if [ -z "${log_timestamp}" ] ;then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
			else
				printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
			fi
		fi

		if [ $((log_conf & b_log_to_syslog)) -gt "0" ] ;then
			if [ $((log_conf & b_logger_bin_available)) -gt "0" ] ;then
				${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
			fi
		fi
	fi
}

sigHandler()
{
	local signal="${1:-}"
	local bash_lineno="${2:-}"
	local bash_command="${3:-}"
	local rc=

	case "${signal}" in
		SIGTERM)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="143"
			exit
			;;
		SIGINT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="130"
			exit
			;;
		SIGHUP)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="129"
			exit
			;;
		SIGABRT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="129"
			exit
			;;
		ERR)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', at line number: '${bash_lineno}', command: '${bash_command}'." 
			fi

			script_exit_code="1"
			exit
			;;
		EXIT)
			logHandler "Caught: '${signal}', exiting script..."

			if [ "${script_bypass_exit_routines}" != "1" ] ;then
				cleanUp

				if ([ "${backup_encryption_enabled:-}" == "1" ] && [ "${encryption_successful:-}" == "1" ]) || ([ "${backup_encryption_enabled:-}" == "0" ] && [ "${backup_successful:-}" == "1" ]);then
					script_exit_code="0"
					rotateHandler
				fi

				if [ "${script_exit_code}" == "0" ] ;then
					logHandler "We did a great job. :)"
				else
					logHandler "Ooops!!! Something went wrong. :("
					logHandler "Read the log or output to determine what exactly went wrong."
				fi

				if [ "${script_another_instance_is_running}" != "1" ] ;then
					checkLock
					rc="${?}"

					if [ "${rc}" == "0" ] ;then
						removeLock
					fi
				fi
			fi

			logHandler "Script was running: '${SECONDS}' seconds, script_exit_code: '${script_exit_code}'."
			logHandler "Bye, bye..."

			if [ -n "${kill_bin:-}" ] ;then
				if [ "${signal}" != "EXIT" ] ;then
					${kill_bin} -s "${signal}" -- -"${script_pid}"
				else
					script_shutdown_in_progress="1"
					${kill_bin} -s SIGTERM -- -"${script_pid}"
				fi
			fi

			exit ${script_exit_code}
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}', but dont know what to do with it..."
			return 1
			;;
	esac
}

checkLock()
{
	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read and writeable..."

	checkFileParameters "${script_lock_file}"

	if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_read)) -gt "0" ] && [ $((file_permission & b_permission_write)) -gt "0" ]) ;then
		logHandler "Lock file exists and it is read/writeable."
		return 0
	elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
		logHandler "Lock file doesnt exist."
		return 1
	else
		logHandler "Lock file exists, but it is not read/writeable."
		return 2
	fi
}

setLock()
{
	local rc=

	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkFileParameters "${script_lock_directory}"

	if ([ $((file_permission & b_is_directory)) -gt "0" ] && [ $((file_permission & b_permission_read)) -gt "0" ] && [ $((file_permission & b_permission_execute)) -gt "0" ]) ;then
		logHandler "Script lock directory exists and permissions are ok."
	elif [ $((file_permission & b_is_directory)) -eq "0" ] ;then
		logHandler "Script lock directory doesnt exist."
		logHandler "Creating script lock directory..."

		# shellcheck disable=SC2154
		${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler

		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Creating script lock directory was successful."
		else
			logHandler "Creating script lock directory was not successful."
			script_exit_code="20"
			exit
		fi
	else
		logHandler "Script lock directory exists but permissions are not ok, exiting."
		script_exit_code="21"
		exit
	fi

	logHandler "Setting lock..."

	printf "%s\\n" "${script_pid}" > "${script_lock_file}"
	rc="${?}"

	if [ "${rc}" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="22"
		exit
	fi
}

removeLock()
{
	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	${rm_bin} "${script_lock_file}" 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="30"
		exit
	fi
}

overrideLock()
{
	logHandler "Overriding lock, because you want it..."

	removeLock
	setLock
}

cleanUp()
{
	logHandler "Now we are doing some cleanup jobs..."

	delUnencryptedBackupFile
	delInstalledPackagesFile
}

delUnencryptedBackupFile()
{
	if [ "${backup_encryption_enabled:-}" == "1" ] ;then
		logHandler "Backup encryption is enabled, now we check if unencrypted backup file exists, if it is writeable and delete it..."
		logHandler "Check if unencrypted backup file: '${backup_filename}' exists and if it is writeable..."

		checkFileParameters "${backup_filename}"

		if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_write)) -gt "0" ]) ;then
			logHandler "Unencrypted backup file  exists and it is writeable."
			logHandler "Deleting unencrypted backup file..."

			# shellcheck disable=SC2154
			${rm_bin} "${backup_filename}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Deleting unencrypted backup file was successful."
			else
				logHandler "Deleting unencrypted backup file was not successful."
				script_exit_code="40"
			fi
		elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
			logHandler "Unencrypted backup file doesnt exist, nothing to do."
		else
			logHandler "Unencrypted backup file is not writeable, we can not delete it."
			script_exit_code="41"
		fi
	fi
}

delInstalledPackagesFile()
{
	if [ "${installed_packages_enabled:-}" == "1" ] ;then
		logHandler "Installed packages functionality is enabled, now we check if the file exists, if it is writeable and delete it..."
		logHandler "Check if installed packages file: '${installed_packages_filename}' exists and if it is writeable..."

		checkFileParameters "${installed_packages_filename}"

		if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_write)) -gt "0" ]) ;then
			logHandler "Installed packages file exists and is writeable."
			logHandler "Deleting installed packages file..."

			# shellcheck disable=SC2154
			${rm_bin} "${installed_packages_filename}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Deleting installed packages file was successful."
			else
				logHandler "Deleting installed packages file was not successful."
				script_exit_code="50"
			fi
		elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
			logHandler "Installed packages file doesnt exist, nothing to do."
		else
			logHandler "Installed packages file exists, but it is not writeable, we can not delete it."
			script_exit_code="51"
		fi
	fi
}

checkFileParameters()
{
	local file="${1:-}"

	file_permission=
	b_permission_execute="1"
	b_permission_write="2"
	b_permission_read="4"
	b_regular_file_exists="8"
	b_regular_file_is_not_empty="16"
	b_is_directory="32"

	if [ -x "${file}" ] ;then
		file_permission="$((file_permission | b_permission_execute))"
	fi

	if [ -w "${file}" ] ;then
		file_permission="$((file_permission | b_permission_write))"
	fi

	if [ -r "${file}" ] ;then
		file_permission="$((file_permission | b_permission_read))"
	fi

	if [ -f "${file}" ] ;then
		file_permission="$((file_permission | b_regular_file_exists))"

		if [ -s "${file}" ] ;then
			file_permission="$((file_permission | b_regular_file_is_not_empty))"
		fi
	else
		if [ -d "${file}" ] ;then
			file_permission="$((file_permission | b_is_directory))"
		fi
	fi
}

setDefaultValues()
{
	script_base_path="/usr/local/${script_name}"
	script_lock_directory="${script_base_path}/var/lock"
	script_lock_file="${script_lock_directory}/${script_name}.lock"
	script_config_file="${script_config_file:=${script_base_path}/etc/${script_name}.conf}"
	script_config_name="${script_config_file##*/}"
	script_config_name="${script_config_name//.conf/}"
}

checkOpts()
{
	if [[ ! "${script_config_file}" =~ ^(.*).conf$ ]] ;then
		printf "Unsupported file extension of config file: '%s', exiting.\\n\\n" "${script_config_file}"
		printUsage
		
		script_bypass_exit_routines="1"
		script_exit_code="60"
		exit
	fi
}

checkRootPrivileges()
{
	logHandler "Check if root priviliges are required..."

	if [ "${root_privileges_required}" == "1" ] ;then
		logHandler "Root privileges are required, checking privileges..."

		if [ "$UID" == "0" ] ;then
			logHandler "HOORAY, we have root privileges. :)"
		else
			logHandler "You must run this script as root, terminating."
			script_exit_code="70"
			exit
		fi
	else
		logHandler "Root privileges are not required..."
	fi
}

getUser()
{
	local rc=
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ -n "${SUDO_USER:-}" ] ;then
		script_exec_user="$SUDO_USER"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started by user: '${script_exec_user}'."
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ] ;then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="80"
		exit
	else
		case "${BASH_VERSINFO[0]}" in
					3|4)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
						;;
					*)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."
						script_exit_code="81"
						exit
						;;
		esac
	fi
}

checkAlreadyRunningInstance()
{
	local rc=
	local running_script_pids=

	# shellcheck disable=SC2154
	running_script_pids="$(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_name}(.*)$")"
	running_script_pids="${running_script_pids//${script_pid}/}"

	# shellcheck disable=SC2154
	running_script_pids="${running_script_pids//$(${pgrep_bin} -d " " -P "${script_pid}")/}"
	running_script_pids="${running_script_pids//\ /\,\ }"

	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="${?}"

	if ([ "${rc}" != "0" ] && [ -z "${running_script_pids:-}" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "${rc}" == "0" ] && [ -z "${running_script_pids:-}" ]) ;then
		logHandler "Another instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."

		if [ "${script_override_lock}" == "1" ] ;then
			overrideLock
		else
			logHandler "HINT: You can override the old left over lock by calling ${script_name} with option '-o'."

			script_another_instance_is_running="1"
			script_exit_code="90"
			exit
		fi
	elif ([ "${rc}" == "0" ] && [ -n "${running_script_pids:-}" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"

		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="91"
		exit
	elif ([ "${rc}" != "0" ] && [ -n "${running_script_pids:-}" ]) ;then
		running_script_pids="${running_script_pids:0:$((${#running_script_pids} - 2))}"

		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="92"
		exit
	fi
}

reNice()
{
	logHandler "Check if re-niceing is enabled..."

	if [ "${re_nice_enabled}" == "1" ] ;then
		logHandler "Re-niceing is enabled."
		logHandler "Check if renice priority is in range..."

		if ([ "${re_nice_priority}" -lt "-20" ] || [ "${re_nice_priority}" -gt "19" ]) ;then
			logHandler "Re-nice priority: '${re_nice_priority}' is out of range."
			logHandler "HINT: Have a look at: 'man renice'."

			script_exit_code="100"
			exit
		else
			logHandler "Re-nice priority: '${re_nice_priority}' is in range."
			logHandler "Re-niceing..."

			# shellcheck disable=SC2154
			${renice_bin} -n ${re_nice_priority} -p ${script_pid} 2>&1 | logHandler
			
			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Re-niceing was successful."
			else
				logHandler "Re-niceing was not successful."
				script_exit_code="101"
				exit
			fi
		fi
	else
		logHandler "Re-niceing is not enabled."
	fi
}

reIONice()
{
	local re_ionice_cmd=
	local re_ionice_priority_required=

	logHandler "Check if re-ioniceing is enabled..."

	if [ "${re_ionice_enabled}" == "1" ] ;then
		logHandler "Re-ioniceing is enabled."
		logHandler "Check if re-ioniceing parameters are in range..."

		if ([ "${re_ionice_scheduling_class}" -gt "3" ] || [ "${re_ionice_scheduling_class}" -lt "1" ]) ;then
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is out of range."
			logHandler "HINT: Have a look at: 'man ionice'."

			script_exit_code="110"
			exit
		else
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is in range."
		fi

		if ([ "${re_ionice_scheduling_class}" == "1" ] || [ "${re_ionice_scheduling_class}" == "2" ]) ;then
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' requires re-ioniceing priority."
			logHandler "Check if re-ioniceing priority is in range..."

			re_ionice_priority_required="1"

			if ([ "${re_ionice_priority}" -gt "7" ] || [ "${re_ionice_priority}" -lt "0" ]) ;then
				logHandler "Re-ioniceing priority: '${re_ionice_priority}' is out of range."
				logHandler "HINT: Have a look at: 'man ionice'."

				script_exit_code="111"
				exit
			else
				logHandler "Re-ioniceing priority: '${re_ionice_scheduling_class}' is in range."
			fi
		else
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' does not require a re-ioniceing priority."
		fi

		logHandler "Re-ioniceing..."

		if [ "${re_ionice_priority_required}" == "1" ] ;then
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -n ${re_ionice_priority} -p ${script_pid}"
		else
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -p ${script_pid}"
		fi

		${re_ionice_cmd}  2>&1 | logHandler
		
		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Re-ioniceing was successful."
		else
			logHandler "Re-ioniceing was not successful."
			script_exit_code="112"
			exit
		fi
	else
		logHandler "Re-ioniceing is not enabled."
	fi
}

executePreBackupScript()
{
	local rc=

	logHandler "Check if pre backup script functionality is enabled..."

	if [ "${pre_backup_script_enabled}" == "1" ] ;then
		logHandler "Pre backup script functionality is enabled."
		logHandler "Check if pre backup script (${pre_backup_script}) exists and if it is executeable..."

		checkFileParameters "${pre_backup_script}"

		if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_execute)) -gt "0" ]) ;then
			logHandler "Pre backup script exists and it is executeable, so we execute it..."
		elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
			logHandler "Pre backup script doesnt exist, nothing to do."
			script_exit_code="120"
			exit
		else
			logHandler "Pre backup script exists, but it is not executeable, nothing to do."
			script_exit_code="121"
			exit
		fi

		eval "${pre_backup_script} 2>&1" | logHandler
		rc="${?}"

		if [ "${rc}" == "0" ] ;then
			logHandler "Execution of pre backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of pre backup script was unsuccessful. rc: '${rc}'."

			if [ "${pre_backup_exit_when_unsuccessful}" == "1" ] ;then
				logHandler "Breaking, because execution of pre backup script was unsuccessful und you want it."
				script_exit_code="122"
				exit
			fi
		fi
	else
		logHandler "Pre backup script functionality is not enabled."
	fi
}

checkBackupDirStructure()
{
	local dir=
	local dir_helper=
	local backup_dirs=("daily" "weekly" "monthly" "latest")
	backup_base_directory="${backup_destination_path}/${HOSTNAME}/${script_config_name}"

	logHandler "Check backup dir structure..."
	logHandler "Check if backup directory: '${backup_destination_path}' exists and permissions to move files are ok..."

	checkFileParameters "${backup_destination_path}"

	if ([ $((file_permission & b_is_directory)) -gt "0" ] && [ $((file_permission & b_permission_read)) -gt "0" ] && [ $((file_permission & b_permission_execute)) -gt "0" ]) ;then
		logHandler "Backup directory exists and permissions are ok."
	elif [ $((file_permission & b_is_directory)) -eq "0" ] ;then
		logHandler "Backup directory doesnt exist."
		logHandler "Creating backup directory..."

		# shellcheck disable=SC2154
		${mkdir_bin} -p "${backup_destination_path}" 2>&1 | logHandler

		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Creating backup directory was successful."
		else
			logHandler "Creating backup directory was not successful."
			script_exit_code="130"
			exit
		fi
	else
		logHandler "Backup directory exists but permissions are not ok, exiting."
		script_exit_code="131"
		exit
	fi

	for dir in "${backup_dirs[@]}"
	   do
	   	dir_helper="${backup_base_directory}/${dir}"

	   	checkFileParameters "${dir_helper}"

		if ([ $((file_permission & b_is_directory)) -gt "0" ] && [ $((file_permission & b_permission_read)) -gt "0" ] && [ $((file_permission & b_permission_execute)) -gt "0" ]) ;then
			logHandler "Directory: '${dir_helper}' exist, nothing to do."
		elif [ $((file_permission & b_is_directory)) -eq "0" ] ;then
			logHandler "Directory: '${dir_helper}' doesnt exist."
			logHandler "Creating directory..."

			# shellcheck disable=SC2154
			${mkdir_bin} -p "${dir_helper}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Creating directory: '${dir_helper}' was successful."
			else
				logHandler "Creating directory: '${dir_helper}' was not successful."
				script_exit_code="132"
				exit
			fi
		else
			logHandler "Directory: '${dir_helper}' exists but permissions are not ok, exiting."
			script_exit_code="133"
			exit
		fi
	   done
}

bubbleSort()
{
	local array=("${@}")
	local elements="${#array[@]}"
	local i="$((elements - 1))"
	local j=
	local temp_value=

	while [ "${i}" -gt "0" ]
	   do
	   	j="0"

		while [ "${j}" -lt "${i}" ]
		   do
		   	if [[ "${array[${j}]}" > "${array[$((j + 1))]}" ]] ;then
				temp_value="${array[${j}]}"
				array[${j}]="${array[$((j + 1))]}"
				array[$((j + 1))]="${temp_value}"
			fi

			j="$((j + 1))"
		   done

		   i="$((i - 1))"
	   done
	
	printf "%s\\n" "${array[@]}"
}

removeTodaysOldBackups()
{
	local file=
	local todays_timestamp=
	todays_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_timestamp_base_format}${date_cmd_format_suffix}")"
	local backup_files_base_name="${backup_base_directory}/${rotation_type}/${rotation_type}_${backup_base_filename}_${todays_timestamp}*.${file_extension}"
	# shellcheck disable=SC2206
	local backup_files=(${backup_files_base_name})

	logHandler "Check if old backups of type: '${rotation_type}' from today exists..."

	for file in "${backup_files[@]}"
	   do
	   	if [ "${file}" == "${backup_files[*]}" ] ;then
			logHandler "No old backups of type: '${rotation_type}' from today found."
			return
		fi

	   	logHandler "Backup from today: '${file}' found..."
		logHandler "Check if permissions of file: '${file}' are ok to delete it..."

		checkFileParameters "${file}"

		if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_write)) -gt "0" ]) ;then
			logHandler "We have write permissions, so we can delete it."

			# shellcheck disable=SC2154
			${rm_bin} "${file}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Deleting file was successful."
			else
				logHandler "Deleting file was not successful."
				script_exit_code="140"
				exit
			fi
		elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
			logHandler "File doenst exist, nothing to do."
		else
			logHandler "We dont have write permissions, nothing to do."
		fi
	   done
}

removeOldBackups()
{
	local file=
	local backup_files_base_name="${backup_base_directory}/${rotation_type}/${rotation_type}_${backup_base_filename}_"
	# shellcheck disable=SC2206
	local backup_files=(${backup_files_base_name}*.${file_extension})
	# shellcheck disable=SC2207
	local backup_files_sorted=($(bubbleSort "${backup_files[@]}"))
	local backup_files_count="${#backup_files[*]}"
	local backups_to_delete_counter=

	logHandler "Check if rotation of ${rotation_type} backups is necessary..."

	case "${rotation_type}" in
				daily)
					if [ "${backup_files_count}" -gt "${backup_rotation_daily_max_backups}" ] ;then
						backups_to_delete_counter="$((backup_files_count - backup_rotation_daily_max_backups))"
						logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_daily_max_backups: '${backup_rotation_daily_max_backups}')."
					else
						logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_daily_max_backups: '${backup_rotation_daily_max_backups}')."
						return
					fi
					;;
				weekly)
					if [ "${backup_files_count}" -gt "${backup_rotation_weekly_max_backups}" ] ;then
						backups_to_delete_counter="$((backup_files_count - backup_rotation_weekly_max_backups))"
						logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_weekly_max_backups: '${backup_rotation_weekly_max_backups}')."
					else
						logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_weekly_max_backups: '${backup_rotation_weekly_max_backups}')."
						return
					fi
					;;
				monthly)
					if [ "${backup_files_count}" -gt "${backup_rotation_monthly_max_backups}" ] ;then
						backups_to_delete_counter="$((backup_files_count - backup_rotation_monthly_max_backups))"
						logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_monthly_max_backups: '${backup_rotation_monthly_max_backups}')."
					else
						logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_monthly_max_backups: '${backup_rotation_monthly_max_backups}')."
						return
					fi
					;;
	esac

	if [ -n "${backups_to_delete_counter}" ] ;then
		for file in "${backup_files_sorted[@]}"
		   do
		   	if [ "${backups_to_delete_counter}" -gt "0" ] ;then
				logHandler "Backup to delete: '${file}' found..."
				logHandler "Check if permissions of file: '${file}' are ok to delete it..."

				checkFileParameters "${file}"

				if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_write)) -gt "0" ]) ;then
					logHandler "We have write permissions, so we can delete it."

					# shellcheck disable=SC2154
					${rm_bin} "${file}" 2>&1 | logHandler

					if [ "${PIPESTATUS[0]}" == "0" ] ;then
						logHandler "Deleting file was successful."
					else
						logHandler "Deleting file was not successful."
						script_exit_code="150"
						exit
					fi
				elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
					logHandler "File doenst exist, nothing to do."
				else
					logHandler "We dont have write permissions, nothing to do."
				fi

				backups_to_delete_counter="$((backups_to_delete_counter - 1))"
			fi
		   done
	fi
}

rotateHandler()
{
	local file=
	file_extension=
	local file_new=
	local actual_weekday=
	local actual_weekday_format="%u"
	local rotation_timestamp=
	local rotation_types=("daily" "weekly" "monthly")
	rotation_type=
	rotation_timestamp_base_format="%Y-%m-%d"
	local rotation_daily_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%A"
	local rotation_weekly_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%W"
	local rotation_monthly_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%B"

	logHandler "Check if backup rotation is enabled..."

	if ([ "${backup_rotation_daily_enabled}" == "1" ] || [ "${backup_rotation_weekly_enabled}" == "1" ] || [ "${backup_rotation_monthly_enabled}" == "1" ]) ;then
		logHandler "Backup rotation is enabled."
		logHandler "Check if only one backup per day is enabled..."

		if [ "${backup_rotation_one_backup_per_day_only}" ] ;then
			logHandler "Only one backup per day is enabled."
		else
			logHandler "Only one backup per day is not enabled."
		fi

		if [ "${backup_encryption_enabled}" == "1" ] ;then
			file="${backup_encryption_filename}"
			file_extension="${backup_encryption_file_extension}"
		else
			file="${backup_filename}"
			file_extension="${backup_file_extension}"
		fi

		actual_weekday="$(eval "${date_bin} ${date_cmd_format_prefix}${actual_weekday_format}${date_cmd_format_suffix}")"

		for rotation_type in "${rotation_types[@]}"
		   do
		   	case "${rotation_type}" in
						daily)
							if [ "${backup_rotation_weekly_enabled}" == "1" ] ;then
								rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_daily_timestamp_format}${date_cmd_format_suffix}")"

								if [ "${backup_rotation_one_backup_per_day_only}" ] ;then
									removeTodaysOldBackups
								fi

								file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

								logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

								# shellcheck disable=SC2154
								${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler

								if [ "${PIPESTATUS[0]}" == "0" ] ;then
									logHandler "Copy job was successful."
								else
									logHandler "Copy job was not successful."
									script_exit_code="160"
									exit
								fi
							fi
							;;
						weekly)
							if [ "${backup_rotation_weekly_enabled}" == "1" ] ;then
								logHandler "Check if today is the day, where ${rotation_type} backups should be rotated..."

								if [ "${actual_weekday}" == "${backup_rotation_weekly_weekday}" ] ;then
									logHandler "Today is the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' == backup_rotation_weekly_weekday: '${backup_rotation_weekly_weekday}')."

									rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_weekly_timestamp_format}${date_cmd_format_suffix}")"

									if [ "${backup_rotation_one_backup_per_day_only}" ] ;then
										removeTodaysOldBackups
									fi

									file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

									logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

									# shellcheck disable=SC2154
									${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler

									if [ "${PIPESTATUS[0]}" == "0" ] ;then
										logHandler "Copy job was successful."
									else
										logHandler "Copy job was not successful."
										script_exit_code="161"
										exit
									fi
								else
									logHandler "Today is not the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' != backup_rotation_weekly_weekday: '${backup_rotation_weekly_weekday}')."
								fi
							fi
							;;
						monthly)
							if [ "${backup_rotation_monthly_enabled}" == "1" ] ;then
								logHandler "Check if today is the day, where ${rotation_type} backups should be rotated..."

								if [ "${actual_weekday}" == "${backup_rotation_monthly_weekday}" ] ;then
									logHandler "Today is the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' == backup_rotation_monthly_weekday: '${backup_rotation_monthly_weekday}')."

									rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_monthly_timestamp_format}${date_cmd_format_suffix}")"

									if [ "${backup_rotation_one_backup_per_day_only}" ] ;then
										removeTodaysOldBackups
									fi

									file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

									logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

									# shellcheck disable=SC2154
									${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler

									if [ "${PIPESTATUS[0]}" == "0" ] ;then
										logHandler "Copy job was successful."
									else
										logHandler "Copy job was not successful."
										script_exit_code="162"
										exit
									fi
								else
									logHandler "Today is not the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' != backup_rotation_monthly_weekday: '${backup_rotation_monthly_weekday}')."
								fi
							fi
							;;
			esac

			removeOldBackups
		   done
	else
		logHandler "Backup rotation is not enabled."
	fi
}

createInstalledPackagesFile()
{
	local rc=
	local syspackage_manager=
	local available_syspackage_managers_helper=

	logHandler "Check if installed packages are enabled..."

	if [ "${installed_packages_enabled}" == "1" ] ;then
		logHandler "Installed packages are enabled."

		if [ "${#available_syspackage_managers[*]}" -gt "1" ] ;then
			available_syspackage_managers_helper="${available_syspackage_managers[*]}"
			available_syspackage_managers_helper="${available_syspackage_managers_helper//\ /\,\ }"

			logHandler "More than one supported syspackage managers found: '${available_syspackage_managers_helper}', dont know what to do, exiting."

			if [ -z "${installed_packages_forced_manager}" ] ;then
				logHandler "HINT: You can force to use one of the supported syspackage managers by setting configuration variable: 'installed_packages_forced_manager'."
			fi

			script_exit_code="170"
			exit
		elif [ "${#available_syspackage_managers[*]}" -eq "1" ] ;then
			syspackage_manager="${available_syspackage_managers[*]}"
			logHandler "The supported system package manager we found is: '${syspackage_manager}'."
		elif [ "${#available_syspackage_managers[*]}" -eq "0" ] ;then
			logHandler "No supported system package manager found, exiting."
			script_exit_code="171"
			exit
		fi

		logHandler "Creating installed packages file: '${installed_packages_filename}'..."

		case "${syspackage_manager}" in
						rpm)
							${syspackage_manager} -qa > "${installed_packages_filename}"
							;;
						dpkg)
							${syspackage_manager} --get-selections > "${installed_packages_filename}"
							;;
						pacman)
							${syspackage_manager} -Qqe > "${installed_packages_filename}"
							;;
						equery)
							${syspackage_manager} list "*" > "${installed_packages_filename}"
							;;
						pkgutil)
							${syspackage_manager} --pkgs > "${installed_packages_filename}"
							;;
						*)
							logHandler "Unsupported syspackage manager used in function: '${FUNCNAME[0]}'. :( Exiting."
							script_exit_code="172"
							exit
							;;
		esac

		rc="${?}"

		if [ "${rc}" == "0" ] ;then
			logHandler "Creating installed packages file was successful, adding file to backup_items config array."
			backup_items+=("${installed_packages_filename}")
		else
			logHandler "Creating installed packages file was not successful."
			script_exit_code="173"
			exit
		fi
	else
		logHandler "Installed packages are not enabled..."
	fi
}

buildExcludeOpts()
{
	local rc=
	local item=

	logHandler "Check if we need to build excluding options..."

	if [ -n "${backup_exlude_items[*]:-}" ] ;then
		logHandler "Building of excluding options is enabled."
		exclude_string=()

		for item in "${backup_exlude_items[@]}"
		   do
			exclude_string+=("--exclude='${item}'")
		   done

		logHandler "We build the following excluding options: '${exclude_string[*]}'."
	else
		logHandler "We dont have to build excluding options..."
	fi
}

buildBackupOpts()
{
	logHandler "Building backup options..."

	backup_options=("--create")

	if [ "${backup_compression_enabled}" == "1" ] ;then
		case "${backup_compression_type}" in
							gzip)
								backup_options+=("--gzip")
								backup_file_extension="tar.gz"
								;;
							bzip2)
								backup_options+=("--bzip2")
								backup_file_extension="tar.bz"
								;;
							xz)
								backup_options+=("--xz")
								backup_file_extension="tar.xz"
								;;
							lzip)
								backup_options+=("--lzip")
								backup_file_extension="tar.lz"
								;;
							lzma)
								backup_options+=("--lzma")
								backup_file_extension="tar.lzma"
								;;
							lzop)
								backup_options+=("--lzop")
								backup_file_extension="tar.lzop"
								;;
							*)
								logHandler "Unsupported compression type configured, exiting."
								script_exit_code="180"
								exit
								;;
		esac
	fi

	backup_filename="${backup_base_directory}/latest/${backup_base_filename}.${backup_file_extension}"
	backup_options+=("--file=${backup_filename}")

	if [ "${backup_verbose_mode_enabled}" == "1" ] ;then
		backup_options+=("--verbose")
	fi

	if [ "${backup_show_totals}" == "1" ] ;then
		backup_options+=("--totals")
	fi

	logHandler "We build the following backup options: '${backup_options[*]}'."
}

makeBackup()
{
	local backup_cmd=

	if [ -z "${exclude_string[*]:-}" ] ;then
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${backup_options[*]} ${backup_items[*]}"
	else
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${backup_options[*]} ${backup_items[*]} ${exclude_string[*]}"
	fi

	logHandler "Starting backup job..."

	${backup_cmd} 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Backup job was successful."
		backup_successful="1"
	else
		logHandler "Backup job was not successful."
		script_exit_code="190"
		exit
	fi
}

encryptBackup()
{
	if [ "${backup_encryption_enabled}" == "1" ] ;then
		backup_encryption_file_extension="aes.${backup_file_extension}"
		backup_encryption_filename="${backup_filename//${backup_file_extension}/${backup_encryption_file_extension}}"

		logHandler "Backup encryption is enabled..."
		logHandler "Encrypting backup file: '${backup_filename}'..."

		# shellcheck disable=SC2154
		${openssl_bin} aes-256-cbc -salt -in "${backup_filename}" -out "${backup_encryption_filename}" -k "${backup_encryption_password}" 2>&1 | logHandler

		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Encrypting job was successful."
			logHandler "HINT: To decrypt use this command: '${openssl_bin} aes-256-cbc -d -salt -in ${backup_encryption_filename} -out ${backup_filename}'."
			encryption_successful="1"
		else
			logHandler "Encrypting job was not successful."
			script_exit_code="200"
			exit
		fi
	else
		logHandler "Backup encryption is not enabled..."
	fi
}

executePostBackupScript()
{
	local rc=

	logHandler "Check if post backup script functionality is enabled..."

	if [ "${post_backup_script_enabled}" == "1" ] ;then
		logHandler "Post backup script functionality is enabled."
		logHandler "Check if post backup script (${post_backup_script}) exists and if it is executeable..."

		checkFileParameters "${post_backup_script}"

		if ([ $((file_permission & b_regular_file_exists)) -gt "0" ] && [ $((file_permission & b_permission_execute)) -gt "0" ]) ;then
			logHandler "Post backup script exists and it is executeable, so we execute it..."
		elif [ $((file_permission & b_regular_file_exists)) -eq "0" ] ;then
			logHandler "Post backup script doesnt exist, nothing to do."
			script_exit_code="210"
			exit
		else
			logHandler "Post backup script exists, but it is not executeable, nothing to do."
			script_exit_code="211"
			exit
		fi

		eval "${post_backup_script} 2>&1" | logHandler
		rc="${?}"

		if [ "${rc}" == "0" ] ;then
			logHandler "Execution of post backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of post backup script was unsuccessful. rc: '${rc}'."

			if [ "${post_backup_exit_when_unsuccessful}" == "1" ] ;then
				logHandler "Breaking, because execution of post backup script was unsuccessful und you want it."
				script_exit_code="212"
				exit
			fi
		fi
	else
		logHandler "Post backup script functionality is not enabled."
	fi
}



#-------------
# Get options:
#-------------

OPTERR="0"

# shellcheck disable=SC2213
while getopts ":h.c:o.v." OPTION
   do
	case "${OPTION}" in
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="220"
				exit
				;;
			c)
				script_config_file="${OPTARG}"
				;;
			o)
				script_override_lock="1"
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="221"
				exit
				;;
			\?)
				printf "Invalid option: -%s\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="222"
				exit
				;;
			:)
				printf "Option: -%s requires an argument.\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="223"
				exit
				;;
	esac
   done



#------
# Main:
#------

setDefaultValues
checkOpts
includeConfig
checkRootPrivileges
getUser
checkBashVersion
checkAlreadyRunningInstance
reNice
reIONice
checkBackupDirStructure
executePreBackupScript
createInstalledPackagesFile
buildExcludeOpts
buildBackupOpts
makeBackup
encryptBackup
executePostBackupScript

exit



#-------------------------
# Should never be reached:
#-------------------------

logHandler "Ooops!!! Something went terribly wrong... :( Exiting."
exit
